#!/usr/bin/env tsx

/**
 * Seed Stock on Hand Script
 *
 * This script seeds initial stock on hand data for all selected products
 * in the active inventory selection.
 *
 * Usage: npx tsx scripts/seed_stock_on_hand.ts
 */

import { neonDb } from "../lib/database/neon-connection";
import { stockService } from "../src/lib/services/StockService";
import type { StockOnHand } from "../src/types/nxt-spp";

// Configuration
const DEFAULT_LOCATION_NAME = "Main Warehouse";
const DEFAULT_LOCATION_TYPE = "internal";
const INITIAL_QTY_MIN = 10;
const INITIAL_QTY_MAX = 100;

interface StockSeedStats {
  locationId: string;
  totalProducts: number;
  totalInventoryValue: number;
  averageQty: number;
  duration: number;
}

/**
 * Ensure default location exists
 */
async function ensureDefaultLocationExists(): Promise<string> {
  try {
    // Check if default location exists
    const existingLocation = await neonDb`
      SELECT location_id FROM core.stock_location 
      WHERE name = ${DEFAULT_LOCATION_NAME} AND type = ${DEFAULT_LOCATION_TYPE} AND is_active = true
    `;

    if (existingLocation.length > 0) {
      console.log(`‚úì Using existing location: ${DEFAULT_LOCATION_NAME}`);
      return existingLocation[0].location_id;
    }

    // Create new location
    const newLocation = await neonDb`
      INSERT INTO core.stock_location (name, type, is_active, created_at, updated_at)
      VALUES (${DEFAULT_LOCATION_NAME}, ${DEFAULT_LOCATION_TYPE}, true, NOW(), NOW())
      RETURNING location_id
    `;

    console.log(`‚úì Created location: ${DEFAULT_LOCATION_NAME}`);
    return newLocation[0].location_id;
  } catch (error) {
    console.error(`Error ensuring location exists: ${error}`);
    throw error;
  }
}

/**
 * Generate random initial quantity
 */
function generateRandomQty(): number {
  return (
    Math.floor(Math.random() * (INITIAL_QTY_MAX - INITIAL_QTY_MIN + 1)) +
    INITIAL_QTY_MIN
  );
}

/**
 * Main function to seed stock on hand
 */
async function seedStockOnHand(): Promise<StockSeedStats> {
  const startTime = Date.now();
  const stats: StockSeedStats = {
    locationId: "",
    totalProducts: 0,
    totalInventoryValue: 0,
    averageQty: 0,
    duration: 0,
  };

  try {
    console.log("üöÄ Starting stock on hand seeding...");

    // Step 1: Ensure default location exists
    console.log("üìç Ensuring default location exists...");
    const locationId = await ensureDefaultLocationExists();
    stats.locationId = locationId;

    // Step 2: Query all selected products with current prices
    console.log("üìä Querying selected products with current prices...");
    const selectedProducts = await neonDb`
      SELECT 
        sp.supplier_product_id,
        sp.supplier_sku,
        sp.name_from_supplier,
        ph.price as unit_cost,
        ph.currency,
        s.name as supplier_name
      FROM core.inventory_selected_item isi
      JOIN core.inventory_selection sel ON sel.selection_id = isi.selection_id
      JOIN core.supplier_product sp ON sp.supplier_product_id = isi.supplier_product_id
      LEFT JOIN core.price_history ph ON ph.supplier_product_id = sp.supplier_product_id AND ph.is_current = true
      JOIN core.supplier s ON s.supplier_id = sp.supplier_id
      WHERE sel.status = 'active' 
        AND isi.status = 'selected'
        AND sp.is_active = true
      ORDER BY s.name, sp.supplier_sku
    `;

    if (selectedProducts.length === 0) {
      throw new Error(
        "No selected products found. Please run the selection creation script first."
      );
    }

    console.log(`‚úì Found ${selectedProducts.length} selected products`);

    // Step 3: Generate stock records
    console.log("üì¶ Generating stock records...");
    const stockRecords: Omit<StockOnHand, "total_value">[] = [];
    let totalValue = 0;
    let totalQty = 0;

    for (const product of selectedProducts) {
      const qty = generateRandomQty();
      const unitCost = parseFloat(product.unit_cost) || 0;
      const stockRecord: Omit<StockOnHand, "total_value"> = {
        soh_id: "", // Will be generated by database
        location_id: locationId,
        supplier_product_id: product.supplier_product_id,
        qty: qty,
        unit_cost: unitCost,
        as_of_ts: new Date(),
        source: "system",
        created_at: new Date(),
      };

      stockRecords.push(stockRecord);
      totalValue += qty * unitCost;
      totalQty += qty;
    }

    console.log(`‚úì Generated ${stockRecords.length} stock records`);
    console.log(`üí∞ Total inventory value: ${totalValue.toFixed(2)}`);

    // Step 4: Bulk import stock in batches
    console.log("üíæ Importing stock records...");
    const batchSize = 100;
    let importedCount = 0;

    for (let i = 0; i < stockRecords.length; i += batchSize) {
      const batch = stockRecords.slice(i, i + batchSize);

      try {
        await stockService.bulkImportStock(batch);
        importedCount += batch.length;

        const progress = Math.round(
          (importedCount / stockRecords.length) * 100
        );
        console.log(
          `üìä Progress: ${progress}% (${importedCount}/${stockRecords.length} records)`
        );
      } catch (error) {
        console.error(
          `‚ùå Error importing batch ${Math.floor(i / batchSize) + 1}:`,
          error
        );
        // Continue with next batch
      }
    }

    // Step 5: Verify stock records were created
    console.log("üîç Verifying stock records...");
    const createdStockRecords = await neonDb`
      SELECT COUNT(*) as count, SUM(qty) as total_qty, SUM(total_value) as total_value
      FROM core.stock_on_hand 
      WHERE location_id = ${locationId}
    `;

    const recordCount = parseInt(createdStockRecords[0].count);
    const verifiedTotalQty = parseInt(createdStockRecords[0].total_qty) || 0;
    const verifiedTotalValue =
      parseFloat(createdStockRecords[0].total_value) || 0;

    console.log(`‚úì Verified: ${recordCount} stock records created`);
    console.log(`‚úì Verified: Total quantity: ${verifiedTotalQty}`);
    console.log(`‚úì Verified: Total value: ${verifiedTotalValue.toFixed(2)}`);

    if (recordCount === 0) {
      throw new Error("No stock records were created");
    }

    // Step 6: Calculate final statistics
    stats.totalProducts = recordCount;
    stats.totalInventoryValue = verifiedTotalValue;
    stats.averageQty = verifiedTotalQty / recordCount;
    stats.duration = Date.now() - startTime;

    // Summary report
    console.log("\nüéâ Stock seeding completed successfully!");
    console.log("========================================");
    console.log(`üìç Location: ${DEFAULT_LOCATION_NAME} (${locationId})`);
    console.log(`üì¶ Total Products: ${stats.totalProducts}`);
    console.log(
      `üí∞ Total Inventory Value: ${stats.totalInventoryValue.toFixed(2)}`
    );
    console.log(`üìä Average Quantity: ${stats.averageQty.toFixed(1)}`);
    console.log(`‚è±Ô∏è  Duration: ${Math.round(stats.duration / 1000)}s`);

    return stats;
  } catch (error) {
    console.error("‚ùå Stock seeding failed:", error);
    throw error;
  }
}

/**
 * Verify stock data integrity
 */
async function verifyStockIntegrity(): Promise<void> {
  try {
    console.log("\nüîç Verifying stock data integrity...");

    // Check for products with stock
    const productsWithStock = await neonDb`
      SELECT COUNT(DISTINCT sp.supplier_product_id) as count
      FROM core.stock_on_hand soh
      JOIN core.supplier_product sp ON sp.supplier_product_id = soh.supplier_product_id
      WHERE sp.is_active = true
    `;

    console.log(`‚úì Products with stock: ${productsWithStock[0].count}`);

    // Check for selected products without stock
    const selectedWithoutStock = await neonDb`
      SELECT COUNT(*) as count
      FROM core.inventory_selected_item isi
      JOIN core.inventory_selection sel ON sel.selection_id = isi.selection_id
      JOIN core.supplier_product sp ON sp.supplier_product_id = isi.supplier_product_id
      LEFT JOIN core.stock_on_hand soh ON soh.supplier_product_id = sp.supplier_product_id
      WHERE sel.status = 'active' 
        AND isi.status = 'selected'
        AND sp.is_active = true
        AND soh.soh_id IS NULL
    `;

    if (selectedWithoutStock[0].count > 0) {
      console.warn(
        `‚ö†Ô∏è  ${selectedWithoutStock[0].count} selected products have no stock records`
      );
    } else {
      console.log(`‚úì All selected products have stock records`);
    }

    // Check for stock records without selected products
    const stockWithoutSelection = await neonDb`
      SELECT COUNT(*) as count
      FROM core.stock_on_hand soh
      LEFT JOIN core.inventory_selected_item isi ON isi.supplier_product_id = soh.supplier_product_id
      LEFT JOIN core.inventory_selection sel ON sel.selection_id = isi.selection_id AND sel.status = 'active'
      WHERE isi.selection_item_id IS NULL OR sel.selection_id IS NULL
    `;

    if (stockWithoutSelection[0].count > 0) {
      console.warn(
        `‚ö†Ô∏è  ${stockWithoutSelection[0].count} stock records are not in active selection`
      );
    } else {
      console.log(`‚úì All stock records are in active selection`);
    }

    // Check inventory value by supplier
    const inventoryBySupplier = await neonDb`
      SELECT 
        s.name as supplier_name,
        COUNT(*) as product_count,
        SUM(soh.qty) as total_qty,
        SUM(soh.total_value) as total_value
      FROM core.stock_on_hand soh
      JOIN core.supplier_product sp ON sp.supplier_product_id = soh.supplier_product_id
      JOIN core.supplier s ON s.supplier_id = sp.supplier_id
      GROUP BY s.supplier_id, s.name
      ORDER BY total_value DESC
      LIMIT 10
    `;

    console.log("üìä Top suppliers by inventory value:");
    inventoryBySupplier.forEach((row, index) => {
      console.log(
        `  ${index + 1}. ${row.supplier_name}: ${row.product_count} products, ${
          row.total_qty
        } qty, ${parseFloat(row.total_value).toFixed(2)} value`
      );
    });
  } catch (error) {
    console.error("‚ùå Stock integrity verification failed:", error);
  }
}

// Command-line execution
if (require.main === module) {
  seedStockOnHand()
    .then(async (stats) => {
      await verifyStockIntegrity();
      console.log("\n‚úÖ Stock on hand seeding completed successfully!");
      console.log(
        `\nüéØ Next step: Run 'npm run integration:verify' to verify the complete integration`
      );
      process.exit(0);
    })
    .catch((error) => {
      console.error("\n‚ùå Stock on hand seeding failed:", error);
      process.exit(1);
    });
}

export { seedStockOnHand };
