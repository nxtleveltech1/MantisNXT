import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

// Validation schemas
const CreateAlertRuleSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  type: z.enum(['low_stock', 'out_of_stock', 'expiry_warning', 'quality_issue', 'performance_issue']),
  conditions: z.object({
    field: z.string().min(1, 'Field is required'),
    operator: z.enum(['equals', 'not_equals', 'greater_than', 'less_than', 'greater_equal', 'less_equal', 'contains']),
    value: z.union([z.string(), z.number(), z.boolean()]),
    additionalConditions: z.array(z.object({
      field: z.string(),
      operator: z.enum(['equals', 'not_equals', 'greater_than', 'less_than', 'greater_equal', 'less_equal', 'contains']),
      value: z.union([z.string(), z.number(), z.boolean()]),
      logicalOperator: z.enum(['AND', 'OR']).optional()
    })).optional()
  }),
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  isActive: z.boolean().default(true),
  notificationChannels: z.array(z.enum(['email', 'sms', 'slack', 'webhook', 'in_app'])).default(['in_app']),
  notificationSettings: z.object({
    recipients: z.array(z.string()).optional(),
    webhookUrl: z.string().url().optional(),
    slackChannel: z.string().optional(),
    frequency: z.enum(['immediate', 'hourly', 'daily']).default('immediate'),
    quietHours: z.object({
      enabled: z.boolean().default(false),
      startTime: z.string().optional(),
      endTime: z.string().optional(),
      timezone: z.string().optional()
    }).optional()
  }).optional(),
  autoResolution: z.object({
    enabled: z.boolean().default(false),
    action: z.enum(['create_po', 'transfer_stock', 'adjust_reorder_point', 'mark_resolved']).optional(),
    threshold: z.number().optional(),
    conditions: z.object({
      field: z.string(),
      operator: z.string(),
      value: z.union([z.string(), z.number(), z.boolean()])
    }).optional()
  }).optional()
})

const UpdateAlertRuleSchema = CreateAlertRuleSchema.partial()

const SearchAlertsSchema = z.object({
  type: z.array(z.enum(['low_stock', 'out_of_stock', 'expiry_warning', 'quality_issue', 'performance_issue'])).optional(),
  severity: z.array(z.enum(['low', 'medium', 'high', 'critical'])).optional(),
  status: z.array(z.enum(['active', 'acknowledged', 'resolved', 'snoozed'])).optional(),
  itemId: z.string().optional(),
  warehouseId: z.string().optional(),
  assignedTo: z.string().optional(),
  dateFrom: z.string().optional(),
  dateTo: z.string().optional(),
  isActive: z.boolean().optional(),
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
  sortBy: z.enum(['createdAt', 'severity', 'type', 'status', 'priority']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
})

const AlertActionSchema = z.object({
  action: z.enum(['acknowledge', 'resolve', 'snooze', 'assign', 'escalate']),
  notes: z.string().optional(),
  assignedTo: z.string().optional(),
  snoozeUntil: z.string().optional(),
  escalationLevel: z.number().optional()
})

// Mock database
let mockAlerts = [
  {
    id: 'alert_001',
    ruleId: 'rule_001',
    ruleName: 'Low Stock Alert - Electronics',
    type: 'low_stock',
    severity: 'high',
    title: 'Low Stock Alert',
    message: 'Dell XPS 13 Laptop stock is running low',
    itemId: 'item_001',
    itemName: 'Dell XPS 13 Laptop (i7, 16GB)',
    itemSku: 'DELL-XPS13-001',
    warehouseId: 'wh_001',
    warehouseName: 'Main Warehouse',
    currentValue: 22,
    threshold: 10,
    status: 'active',
    priority: 85,
    isActive: true,
    assignedTo: null,
    assignedToName: null,
    acknowledgedBy: null,
    acknowledgedAt: null,
    resolvedBy: null,
    resolvedAt: null,
    snoozedUntil: null,
    escalationLevel: 0,
    autoResolution: {
      enabled: true,
      action: 'create_po',
      threshold: 5,
      lastAttempt: null,
      attempts: 0,
      maxAttempts: 3
    },
    metadata: {
      category: 'Electronics',
      supplier: 'Dell Technologies',
      lastOrderDate: '2024-09-15',
      averageConsumption: 5,
      leadTime: 7
    },
    notifications: [
      {
        id: 'notif_001',
        channel: 'email',
        recipient: 'inventory@company.com',
        sentAt: new Date('2024-09-22T08:00:00'),
        status: 'sent'
      }
    ],
    createdAt: new Date('2024-09-22T08:00:00'),
    updatedAt: new Date('2024-09-22T08:00:00'),
    history: [
      {
        id: 'hist_001',
        action: 'created',
        performedBy: 'system',
        timestamp: new Date('2024-09-22T08:00:00'),
        notes: 'Alert automatically generated by low stock rule'
      }
    ]
  },
  {
    id: 'alert_002',
    ruleId: 'rule_002',
    ruleName: 'Out of Stock Alert - Critical Items',
    type: 'out_of_stock',
    severity: 'critical',
    title: 'Out of Stock Alert',
    message: 'Critical component ABC-123 is completely out of stock',
    itemId: 'item_002',
    itemName: 'Critical Component ABC-123',
    itemSku: 'ABC-123',
    warehouseId: 'wh_001',
    warehouseName: 'Main Warehouse',
    currentValue: 0,
    threshold: 0,
    status: 'acknowledged',
    priority: 100,
    isActive: true,
    assignedTo: 'manager@company.com',
    assignedToName: 'John Manager',
    acknowledgedBy: 'manager@company.com',
    acknowledgedAt: new Date('2024-09-22T09:30:00'),
    resolvedBy: null,
    resolvedAt: null,
    snoozedUntil: null,
    escalationLevel: 1,
    autoResolution: {
      enabled: false,
      action: null,
      threshold: null,
      lastAttempt: null,
      attempts: 0,
      maxAttempts: 0
    },
    metadata: {
      category: 'Components',
      supplier: 'ABC Supplier',
      lastOrderDate: null,
      averageConsumption: 2,
      leadTime: 14
    },
    notifications: [
      {
        id: 'notif_002',
        channel: 'email',
        recipient: 'manager@company.com',
        sentAt: new Date('2024-09-22T09:00:00'),
        status: 'sent'
      },
      {
        id: 'notif_003',
        channel: 'slack',
        recipient: '#inventory-alerts',
        sentAt: new Date('2024-09-22T09:05:00'),
        status: 'sent'
      }
    ],
    createdAt: new Date('2024-09-22T09:00:00'),
    updatedAt: new Date('2024-09-22T09:30:00'),
    history: [
      {
        id: 'hist_002',
        action: 'created',
        performedBy: 'system',
        timestamp: new Date('2024-09-22T09:00:00'),
        notes: 'Alert automatically generated by out of stock rule'
      },
      {
        id: 'hist_003',
        action: 'acknowledged',
        performedBy: 'manager@company.com',
        timestamp: new Date('2024-09-22T09:30:00'),
        notes: 'Acknowledged - creating emergency purchase order'
      }
    ]
  }
]

let mockAlertRules = [
  {
    id: 'rule_001',
    name: 'Low Stock Alert - Electronics',
    description: 'Alert when electronics items fall below reorder point',
    type: 'low_stock',
    conditions: {
      field: 'currentStock',
      operator: 'less_equal',
      value: 'reorderPoint',
      additionalConditions: [
        {
          field: 'category',
          operator: 'equals',
          value: 'Electronics',
          logicalOperator: 'AND'
        }
      ]
    },
    severity: 'high',
    isActive: true,
    notificationChannels: ['email', 'in_app'],
    notificationSettings: {
      recipients: ['inventory@company.com'],
      frequency: 'immediate'
    },
    autoResolution: {
      enabled: true,
      action: 'create_po',
      threshold: 5
    },
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-09-22'),
    createdBy: 'admin@company.com',
    lastTriggered: new Date('2024-09-22T08:00:00'),
    triggerCount: 15
  }
]

// GET /api/alerts - List alerts with filtering and pagination
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)

    const queryParams = {
      type: searchParams.get('type')?.split(',') || undefined,
      severity: searchParams.get('severity')?.split(',') || undefined,
      status: searchParams.get('status')?.split(',') || undefined,
      itemId: searchParams.get('itemId') || undefined,
      warehouseId: searchParams.get('warehouseId') || undefined,
      assignedTo: searchParams.get('assignedTo') || undefined,
      dateFrom: searchParams.get('dateFrom') || undefined,
      dateTo: searchParams.get('dateTo') || undefined,
      isActive: searchParams.get('isActive') === 'true' || undefined,
      page: parseInt(searchParams.get('page') || '1'),
      limit: parseInt(searchParams.get('limit') || '20'),
      sortBy: searchParams.get('sortBy') || 'createdAt',
      sortOrder: searchParams.get('sortOrder') as 'asc' | 'desc' || 'desc'
    }

    const validatedParams = SearchAlertsSchema.parse(queryParams)

    // Apply filters
    let filteredAlerts = mockAlerts.filter(alert => {
      // Type filter
      if (validatedParams.type && validatedParams.type.length > 0) {
        if (!validatedParams.type.includes(alert.type)) return false
      }

      // Severity filter
      if (validatedParams.severity && validatedParams.severity.length > 0) {
        if (!validatedParams.severity.includes(alert.severity)) return false
      }

      // Status filter
      if (validatedParams.status && validatedParams.status.length > 0) {
        if (!validatedParams.status.includes(alert.status)) return false
      }

      // Item filter
      if (validatedParams.itemId && alert.itemId !== validatedParams.itemId) {
        return false
      }

      // Warehouse filter
      if (validatedParams.warehouseId && alert.warehouseId !== validatedParams.warehouseId) {
        return false
      }

      // Assigned to filter
      if (validatedParams.assignedTo && alert.assignedTo !== validatedParams.assignedTo) {
        return false
      }

      // Date range filter
      if (validatedParams.dateFrom) {
        const fromDate = new Date(validatedParams.dateFrom)
        if (alert.createdAt < fromDate) return false
      }

      if (validatedParams.dateTo) {
        const toDate = new Date(validatedParams.dateTo)
        toDate.setHours(23, 59, 59, 999)
        if (alert.createdAt > toDate) return false
      }

      // Active filter
      if (validatedParams.isActive !== undefined && alert.isActive !== validatedParams.isActive) {
        return false
      }

      return true
    })

    // Apply sorting
    filteredAlerts.sort((a, b) => {
      let aValue: any, bValue: any

      switch (validatedParams.sortBy) {
        case 'createdAt':
          aValue = a.createdAt
          bValue = b.createdAt
          break
        case 'severity':
          const severityOrder = { low: 1, medium: 2, high: 3, critical: 4 }
          aValue = severityOrder[a.severity]
          bValue = severityOrder[b.severity]
          break
        case 'type':
          aValue = a.type
          bValue = b.type
          break
        case 'status':
          const statusOrder = { active: 1, acknowledged: 2, snoozed: 3, resolved: 4 }
          aValue = statusOrder[a.status]
          bValue = statusOrder[b.status]
          break
        case 'priority':
          aValue = a.priority
          bValue = b.priority
          break
        default:
          aValue = a.createdAt
          bValue = b.createdAt
      }

      if (aValue < bValue) return validatedParams.sortOrder === 'asc' ? -1 : 1
      if (aValue > bValue) return validatedParams.sortOrder === 'asc' ? 1 : -1
      return 0
    })

    // Apply pagination
    const total = filteredAlerts.length
    const totalPages = Math.ceil(total / validatedParams.limit)
    const offset = (validatedParams.page - 1) * validatedParams.limit
    const paginatedAlerts = filteredAlerts.slice(offset, offset + validatedParams.limit)

    // Calculate summary metrics
    const metrics = {
      totalAlerts: mockAlerts.length,
      activeAlerts: mockAlerts.filter(a => a.status === 'active').length,
      criticalAlerts: mockAlerts.filter(a => a.severity === 'critical').length,
      acknowledgedAlerts: mockAlerts.filter(a => a.status === 'acknowledged').length,
      resolvedAlerts: mockAlerts.filter(a => a.status === 'resolved').length,
      averageResolutionTime: 4.5, // hours
      alertsByType: {
        low_stock: mockAlerts.filter(a => a.type === 'low_stock').length,
        out_of_stock: mockAlerts.filter(a => a.type === 'out_of_stock').length,
        expiry_warning: mockAlerts.filter(a => a.type === 'expiry_warning').length,
        quality_issue: mockAlerts.filter(a => a.type === 'quality_issue').length,
        performance_issue: mockAlerts.filter(a => a.type === 'performance_issue').length
      }
    }

    return NextResponse.json({
      success: true,
      data: paginatedAlerts,
      pagination: {
        page: validatedParams.page,
        limit: validatedParams.limit,
        total,
        totalPages,
        hasNext: validatedParams.page < totalPages,
        hasPrev: validatedParams.page > 1
      },
      metrics,
      filters: validatedParams
    })

  } catch (error) {
    console.error('Error fetching alerts:', error)

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        success: false,
        error: 'Invalid query parameters',
        details: error.errors
      }, { status: 400 })
    }

    return NextResponse.json({
      success: false,
      error: 'Internal server error'
    }, { status: 500 })
  }
}

// POST /api/alerts - Create new alert (manual alert creation)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    // For manual alert creation, we need different validation
    const ManualAlertSchema = z.object({
      type: z.enum(['low_stock', 'out_of_stock', 'expiry_warning', 'quality_issue', 'performance_issue']),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
      title: z.string().min(1, 'Title is required'),
      message: z.string().min(1, 'Message is required'),
      itemId: z.string().optional(),
      warehouseId: z.string().optional(),
      assignedTo: z.string().optional(),
      metadata: z.object({}).optional(),
      notes: z.string().optional()
    })

    const validatedData = ManualAlertSchema.parse(body)

    const newAlert = {
      id: `alert_${Date.now()}`,
      ruleId: null, // Manual alerts don't have rules
      ruleName: null,
      type: validatedData.type,
      severity: validatedData.severity,
      title: validatedData.title,
      message: validatedData.message,
      itemId: validatedData.itemId || null,
      itemName: null, // Would be populated from item lookup
      itemSku: null,
      warehouseId: validatedData.warehouseId || null,
      warehouseName: null, // Would be populated from warehouse lookup
      currentValue: null,
      threshold: null,
      status: 'active',
      priority: validatedData.severity === 'critical' ? 100 :
                validatedData.severity === 'high' ? 75 :
                validatedData.severity === 'medium' ? 50 : 25,
      isActive: true,
      assignedTo: validatedData.assignedTo || null,
      assignedToName: null,
      acknowledgedBy: null,
      acknowledgedAt: null,
      resolvedBy: null,
      resolvedAt: null,
      snoozedUntil: null,
      escalationLevel: 0,
      autoResolution: {
        enabled: false,
        action: null,
        threshold: null,
        lastAttempt: null,
        attempts: 0,
        maxAttempts: 0
      },
      metadata: validatedData.metadata || {},
      notifications: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      history: [
        {
          id: `hist_${Date.now()}`,
          action: 'created',
          performedBy: 'api_user@company.com',
          timestamp: new Date(),
          notes: validatedData.notes || 'Manual alert created via API'
        }
      ]
    }

    mockAlerts.unshift(newAlert)

    return NextResponse.json({
      success: true,
      data: newAlert,
      message: 'Alert created successfully'
    }, { status: 201 })

  } catch (error) {
    console.error('Error creating alert:', error)

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        success: false,
        error: 'Invalid request data',
        details: error.errors
      }, { status: 400 })
    }

    return NextResponse.json({
      success: false,
      error: 'Internal server error'
    }, { status: 500 })
  }
}

// PUT /api/alerts - Batch update alerts (bulk actions)
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json()
    const { alertIds, action } = body

    if (!Array.isArray(alertIds)) {
      return NextResponse.json({
        success: false,
        error: 'Alert IDs must be an array'
      }, { status: 400 })
    }

    const validatedAction = AlertActionSchema.parse(action)

    const updatedAlerts = []
    const notFoundIds = []

    for (const alertId of alertIds) {
      const alertIndex = mockAlerts.findIndex(a => a.id === alertId)
      if (alertIndex === -1) {
        notFoundIds.push(alertId)
        continue
      }

      const alert = mockAlerts[alertIndex]
      const timestamp = new Date()

      // Apply action
      switch (validatedAction.action) {
        case 'acknowledge':
          alert.status = 'acknowledged'
          alert.acknowledgedBy = 'api_user@company.com'
          alert.acknowledgedAt = timestamp
          break
        case 'resolve':
          alert.status = 'resolved'
          alert.resolvedBy = 'api_user@company.com'
          alert.resolvedAt = timestamp
          break
        case 'snooze':
          alert.status = 'snoozed'
          alert.snoozedUntil = validatedAction.snoozeUntil ? new Date(validatedAction.snoozeUntil) : null
          break
        case 'assign':
          alert.assignedTo = validatedAction.assignedTo || null
          break
        case 'escalate':
          alert.escalationLevel = validatedAction.escalationLevel || alert.escalationLevel + 1
          break
      }

      alert.updatedAt = timestamp

      // Add to history
      alert.history.push({
        id: `hist_${Date.now()}_${alertId}`,
        action: validatedAction.action,
        performedBy: 'api_user@company.com',
        timestamp,
        notes: validatedAction.notes || `Alert ${validatedAction.action} via bulk action`
      })

      mockAlerts[alertIndex] = alert
      updatedAlerts.push(alert)
    }

    return NextResponse.json({
      success: true,
      data: {
        updated: updatedAlerts,
        notFound: notFoundIds
      },
      message: `${updatedAlerts.length} alerts updated successfully${notFoundIds.length > 0 ? `, ${notFoundIds.length} not found` : ''}`
    })

  } catch (error) {
    console.error('Error batch updating alerts:', error)

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        success: false,
        error: 'Invalid action data',
        details: error.errors
      }, { status: 400 })
    }

    return NextResponse.json({
      success: false,
      error: 'Internal server error'
    }, { status: 500 })
  }
}