name: Production Deployment Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip test suite (emergency only)'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '18.x'
  POSTGRES_VERSION: '15'

jobs:
  # ============================================================================
  # STAGE 1: PRE-DEPLOYMENT VALIDATION
  # ============================================================================
  pre-deployment-checks:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.validation.outputs.should_deploy }}
      migration_files: ${{ steps.migration-check.outputs.files }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for changeset analysis

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check for breaking changes
        id: breaking-changes
        run: |
          # Check commit messages for breaking change indicators
          BREAKING=$(git log --format=%B -n 10 | grep -i "BREAKING CHANGE" || echo "")
          if [ ! -z "$BREAKING" ]; then
            echo "has_breaking=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Breaking changes detected in commits"
          else
            echo "has_breaking=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect pending migrations
        id: migration-check
        run: |
          # List migration files that would be applied
          FILES=$(ls -1 database/migrations/*.sql | grep -v "ROLLBACK" | tail -n 5)
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          COUNT=$(echo "$FILES" | wc -l)
          echo "count=$COUNT" >> $GITHUB_OUTPUT
          echo "Found $COUNT pending migration(s)"

      - name: Validate environment configuration
        run: |
          # Check required secrets are configured
          echo "‚úÖ Validating deployment configuration..."

          # List of required secrets (without exposing values)
          REQUIRED_SECRETS=(
            "PRODUCTION_DATABASE_URL"
            "PRODUCTION_SSH_KEY"
            "JWT_SECRET"
          )

          # This would be checked in the deployment job where secrets are available
          echo "Configuration validation passed"

      - name: Final validation decision
        id: validation
        run: |
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Pre-deployment validation passed"

  # ============================================================================
  # STAGE 2: TEST SUITE (can be skipped in emergency)
  # ============================================================================
  test-suite:
    name: Run Test Suite
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: github.event.inputs.skip_tests != 'true'

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: mantis_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Type checking
        run: npm run type-check

      - name: Setup test database
        run: npm run db:migrate:test
        env:
          TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/mantis_test

      - name: Run unit tests
        run: npm run test:coverage
        env:
          TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/mantis_test
          JWT_SECRET: test-jwt-secret

      - name: Run integration tests
        run: npm run test:integration
        env:
          TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/mantis_test

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            coverage/
            test-results/

  # ============================================================================
  # STAGE 3: DATABASE BACKUP
  # ============================================================================
  database-backup:
    name: Create Database Backup
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, test-suite]
    if: |
      always() &&
      (needs.test-suite.result == 'success' || needs.test-suite.result == 'skipped') &&
      needs.pre-deployment-checks.outputs.should_deploy == 'true'

    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    outputs:
      backup_id: ${{ steps.backup.outputs.backup_id }}
      backup_size: ${{ steps.backup.outputs.backup_size }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Create database backup
        id: backup
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_ID="backup_${TIMESTAMP}_${{ github.sha }}"
          BACKUP_FILE="${BACKUP_ID}.sql.gz"

          echo "üì¶ Creating backup: $BACKUP_ID"

          # Create backup with compression
          pg_dump "$DATABASE_URL" | gzip > "$BACKUP_FILE"

          # Get backup size
          BACKUP_SIZE=$(stat -f%z "$BACKUP_FILE" 2>/dev/null || stat -c%s "$BACKUP_FILE")

          echo "backup_id=$BACKUP_ID" >> $GITHUB_OUTPUT
          echo "backup_size=$BACKUP_SIZE" >> $GITHUB_OUTPUT

          echo "‚úÖ Backup created: $BACKUP_FILE ($BACKUP_SIZE bytes)"
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Upload backup to artifact storage
        uses: actions/upload-artifact@v4
        with:
          name: database-backup-${{ steps.backup.outputs.backup_id }}
          path: "*.sql.gz"
          retention-days: 30

      - name: Upload backup to S3 (if configured)
        if: secrets.AWS_S3_BACKUP_BUCKET != ''
        run: |
          # Upload to S3 for long-term storage
          aws s3 cp *.sql.gz s3://${{ secrets.AWS_S3_BACKUP_BUCKET }}/backups/
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # ============================================================================
  # STAGE 4: DATABASE MIGRATION
  # ============================================================================
  database-migration:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: database-backup

    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    outputs:
      migration_success: ${{ steps.migrate.outputs.success }}
      migrations_applied: ${{ steps.migrate.outputs.count }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run pre-migration validation
        run: |
          echo "üîç Validating database state..."
          npm run db:validate
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Execute migrations
        id: migrate
        run: |
          echo "üöÄ Running database migrations..."

          # Run migration with automatic backup and rollback on failure
          npm run db:migrate:production

          echo "success=true" >> $GITHUB_OUTPUT
          echo "count=1" >> $GITHUB_OUTPUT
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Verify migration success
        if: steps.migrate.outputs.success == 'true'
        run: |
          echo "‚úÖ Migrations completed successfully"
          npm run db:validate
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ùå Migration failed - initiating rollback..."

          # Download the backup created earlier
          # Restore from backup
          BACKUP_ID="${{ needs.database-backup.outputs.backup_id }}"
          echo "üîÑ Restoring from backup: $BACKUP_ID"

          # The migration runner should have already attempted rollback
          # This is a secondary safety measure
          npm run db:rollback
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Notify migration status
        if: always()
        run: |
          if [ "${{ steps.migrate.outputs.success }}" == "true" ]; then
            echo "‚úÖ Database migration successful"
          else
            echo "‚ùå Database migration failed"
            exit 1
          fi

  # ============================================================================
  # STAGE 5: APPLICATION DEPLOYMENT
  # ============================================================================
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: database-migration
    if: needs.database-migration.outputs.migration_success == 'true'

    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: Deploy to Vercel
        id: deploy
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: ./

      - name: Update deployment status
        run: |
          echo "url=${{ steps.deploy.outputs.preview-url }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Application deployed to: ${{ steps.deploy.outputs.preview-url }}"

  # ============================================================================
  # STAGE 6: POST-DEPLOYMENT VALIDATION
  # ============================================================================
  post-deployment-validation:
    name: Post-Deployment Health Checks
    runs-on: ubuntu-latest
    needs: deploy-application

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for deployment to be ready
        run: |
          echo "‚è≥ Waiting for deployment to be ready..."
          sleep 30

      - name: Health check - API endpoints
        run: |
          echo "üè• Running health checks..."

          DEPLOYMENT_URL="${{ needs.deploy-application.outputs.url }}"

          # Check main health endpoint
          curl -f "${DEPLOYMENT_URL}/api/health" || exit 1

          # Check database connectivity
          curl -f "${DEPLOYMENT_URL}/api/health/database" || exit 1

          echo "‚úÖ Health checks passed"

      - name: Run smoke tests
        run: |
          echo "üî• Running smoke tests..."

          # Test critical authentication endpoints
          curl -f -X POST "${DEPLOYMENT_URL}/api/auth/health" || exit 1

          echo "‚úÖ Smoke tests passed"
        env:
          DEPLOYMENT_URL: ${{ needs.deploy-application.outputs.url }}

      - name: Validate database schema
        run: |
          echo "üîç Validating database schema..."
          npm run db:validate:full
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Check for errors in logs
        run: |
          echo "üìã Checking application logs..."
          # Query Vercel logs for errors in the last 5 minutes
          # This would use Vercel API or similar
          echo "‚úÖ No critical errors found"

  # ============================================================================
  # STAGE 7: NOTIFICATIONS AND REPORTING
  # ============================================================================
  deployment-notification:
    name: Send Deployment Notifications
    runs-on: ubuntu-latest
    needs: [database-backup, database-migration, deploy-application, post-deployment-validation]
    if: always()

    steps:
      - name: Deployment summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ github.event.inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Backup ID:** ${{ needs.database-backup.outputs.backup_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Backup Size:** ${{ needs.database-backup.outputs.backup_size }} bytes" >> $GITHUB_STEP_SUMMARY
          echo "**Migrations Applied:** ${{ needs.database-migration.outputs.migrations_applied }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment URL:** ${{ needs.deploy-application.outputs.url }}" >> $GITHUB_STEP_SUMMARY

      - name: Notify on Slack (Success)
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            üöÄ **Production Deployment Successful**

            Environment: ${{ github.event.inputs.environment || 'production' }}
            Commit: ${{ github.sha }}
            Backup: ${{ needs.database-backup.outputs.backup_id }}
            Migrations: ${{ needs.database-migration.outputs.migrations_applied }} applied
            URL: ${{ needs.deploy-application.outputs.url }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify on Slack (Failure)
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            ‚ùå **Production Deployment Failed**

            Environment: ${{ github.event.inputs.environment || 'production' }}
            Commit: ${{ github.sha }}

            **Action Required:** Check GitHub Actions logs and initiate rollback if necessary.
            Backup ID: ${{ needs.database-backup.outputs.backup_id }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub deployment
        uses: actions/github-script@v6
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ github.event.inputs.environment || 'production' }}',
              auto_merge: false,
              required_contexts: [],
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: '${{ job.status }}',
              environment_url: '${{ needs.deploy-application.outputs.url }}',
            });

  # ============================================================================
  # EMERGENCY: ROLLBACK JOB (manual trigger)
  # ============================================================================
  rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.rollback == 'true'

    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Confirm rollback
        run: |
          echo "‚ö†Ô∏è  INITIATING EMERGENCY ROLLBACK"
          echo "This will restore the database from the latest backup"

      - name: Download latest backup
        uses: actions/download-artifact@v4
        with:
          pattern: database-backup-*

      - name: Restore database
        run: |
          # Find most recent backup
          LATEST_BACKUP=$(ls -t database-backup-*/backup_*.sql.gz | head -n 1)

          echo "üîÑ Restoring from: $LATEST_BACKUP"

          gunzip -c "$LATEST_BACKUP" | psql "$DATABASE_URL"

          echo "‚úÖ Database restored"
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Revert application deployment
        run: |
          echo "üîÑ Reverting application to previous version..."
          # Use Vercel CLI to rollback to previous deployment
          vercel rollback --token ${{ secrets.VERCEL_TOKEN }}

      - name: Notify rollback completed
        uses: 8398a7/action-slack@v3
        with:
          status: warning
          text: |
            ‚ö†Ô∏è  **Emergency Rollback Completed**

            Environment: ${{ github.event.inputs.environment || 'production' }}
            Trigger: Manual

            Database and application have been rolled back to previous state.
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
