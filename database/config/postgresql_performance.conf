# ===============================================
# POSTGRESQL PERFORMANCE CONFIGURATION
# Optimized for inventory management workloads
# ===============================================

# =================
# MEMORY SETTINGS
# =================

# Shared memory for buffer cache (25% of total RAM)
shared_buffers = 2GB

# Working memory per operation (should be tuned based on concurrent connections)
work_mem = 16MB

# Memory for maintenance operations (10% of RAM)
maintenance_work_mem = 512MB

# Memory for autovacuum workers
autovacuum_work_mem = 256MB

# Effective cache size (75% of total RAM - helps query planner)
effective_cache_size = 6GB

# =================
# CHECKPOINT SETTINGS
# =================

# Checkpoint segments (higher = less frequent checkpoints, more WAL)
max_wal_size = 4GB
min_wal_size = 1GB

# Checkpoint completion target (spread I/O over time)
checkpoint_completion_target = 0.9

# Checkpoint timeout (time-based checkpoints)
checkpoint_timeout = 15min

# Warning if checkpoints happen too frequently
checkpoint_warning = 30s

# =================
# CONNECTION SETTINGS
# =================

# Maximum number of connections
max_connections = 200

# Reserved connections for superuser
superuser_reserved_connections = 3

# Connection pooling recommended at application level

# =================
# WAL AND REPLICATION
# =================

# WAL level for replication
wal_level = replica

# Archive mode for point-in-time recovery
archive_mode = on
archive_command = 'cp %p /wal_archive/%f'

# Hot standby for read replicas
hot_standby = on

# Synchronous replication (if using replicas)
# synchronous_standby_names = 'standby1'

# =================
# QUERY PLANNER SETTINGS
# =================

# Cost settings (tune based on storage type)
random_page_cost = 1.1  # For SSD storage
seq_page_cost = 1.0

# CPU costs
cpu_tuple_cost = 0.01
cpu_index_tuple_cost = 0.005
cpu_operator_cost = 0.0025

# Parallel query settings
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
max_worker_processes = 8

# Enable parallel queries for larger tables
min_parallel_table_scan_size = 8MB
min_parallel_index_scan_size = 512kB

# =================
# AUTOVACUUM SETTINGS
# =================

# Enable autovacuum
autovacuum = on

# More aggressive autovacuum for high-volume tables
autovacuum_max_workers = 3
autovacuum_naptime = 15s

# Thresholds for vacuum and analyze
autovacuum_vacuum_threshold = 50
autovacuum_analyze_threshold = 50
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_scale_factor = 0.05

# Cost settings to prevent autovacuum from being too aggressive
autovacuum_vacuum_cost_delay = 10ms
autovacuum_vacuum_cost_limit = 1000

# =================
# LOGGING SETTINGS
# =================

# Log slow queries
log_min_duration_statement = 1000  # Log queries > 1 second

# Log checkpoints and connections
log_checkpoints = on
log_connections = on
log_disconnections = on

# Log lock waits
log_lock_waits = on
deadlock_timeout = 1s

# Log temporary file usage
log_temp_files = 10MB

# =================
# SPECIFIC OPTIMIZATIONS FOR INVENTORY
# =================

# Enable JIT for complex queries (PostgreSQL 11+)
jit = on
jit_above_cost = 100000
jit_optimize_above_cost = 500000

# Hash join settings for large joins
enable_hashjoin = on
hash_mem_multiplier = 2.0

# Sort settings for ORDER BY operations
enable_sort = on

# Enable bitmap scans for complex WHERE clauses
enable_bitmapscan = on

# =================
# MAINTENANCE SETTINGS
# =================

# Background writer settings
bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0

# WAL writer settings
wal_writer_delay = 200ms
wal_writer_flush_after = 1MB

# Statistics collection
track_activities = on
track_counts = on
track_io_timing = on
track_functions = all

# =================
# LOCKS AND CONCURRENCY
# =================

# Lock timeout to prevent deadlocks
lock_timeout = 30s

# Statement timeout for runaway queries
statement_timeout = 30min

# Idle in transaction timeout
idle_in_transaction_session_timeout = 10min

# =================
# VACUUM AND ANALYZE SCHEDULING
# =================

# Custom settings for high-volume tables
# These would be applied per table:

# For inventory_movements table (high insert volume):
# ALTER TABLE inventory_movements SET (autovacuum_vacuum_scale_factor = 0.05);
# ALTER TABLE inventory_movements SET (autovacuum_analyze_scale_factor = 0.02);

# For products table (mostly read with occasional updates):
# ALTER TABLE products SET (autovacuum_vacuum_scale_factor = 0.2);
# ALTER TABLE products SET (autovacuum_analyze_scale_factor = 0.1);

# =================
# MONITORING QUERIES
# =================

# Use these queries to monitor performance:

# 1. Check index usage:
# SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read, idx_tup_fetch
# FROM pg_stat_user_indexes
# ORDER BY idx_scan DESC;

# 2. Check table statistics:
# SELECT schemaname, tablename, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch,
#        n_tup_ins, n_tup_upd, n_tup_del
# FROM pg_stat_user_tables
# ORDER BY seq_scan DESC;

# 3. Check cache hit ratio:
# SELECT
#   sum(heap_blks_read) as heap_read,
#   sum(heap_blks_hit) as heap_hit,
#   (sum(heap_blks_hit) - sum(heap_blks_read)) / sum(heap_blks_hit) as ratio
# FROM pg_statio_user_tables;

# 4. Check slow queries:
# SELECT query, calls, total_time, mean_time, max_time
# FROM pg_stat_statements
# ORDER BY mean_time DESC
# LIMIT 20;

# =================
# RECOMMENDED EXTENSIONS
# =================

# Install these extensions for better performance monitoring:
# CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
# CREATE EXTENSION IF NOT EXISTS pg_buffercache;
# CREATE EXTENSION IF NOT EXISTS pg_prewarm;
# CREATE EXTENSION IF NOT EXISTS auto_explain;