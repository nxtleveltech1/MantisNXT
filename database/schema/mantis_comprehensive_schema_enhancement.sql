-- =====================================================
-- MANTIS NXT - COMPREHENSIVE SCHEMA ENHANCEMENT
-- =====================================================
-- Building upon existing foundation to create complete enterprise platform
-- Adds missing business domains while maintaining compatibility
-- Multi-tenant PostgreSQL with advanced RLS security
-- Performance optimized with strategic indexing and partitioning
-- GDPR compliant with comprehensive audit framework
--
-- Generated by Claude Code - MantisNXT Platform Architecture
-- Target: Enterprise-grade SaaS supporting 100K+ users
-- =====================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "hstore";
CREATE EXTENSION IF NOT EXISTS "ltree";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
CREATE EXTENSION IF NOT EXISTS "btree_gin";
CREATE EXTENSION IF NOT EXISTS "btree_gist";

-- =====================================================
-- ENHANCED ENUM DEFINITIONS
-- =====================================================

-- Currency codes (ISO 4217)
CREATE TYPE currency_code AS ENUM (
    'USD', 'EUR', 'GBP', 'JPY', 'CAD', 'AUD', 'CHF', 'CNY', 'INR', 'BRL'
);

-- Payment status for financial transactions
CREATE TYPE payment_status AS ENUM (
    'pending', 'processing', 'completed', 'failed', 'cancelled', 'refunded', 'disputed'
);

-- Payment methods
CREATE TYPE payment_method AS ENUM (
    'credit_card', 'debit_card', 'bank_transfer', 'paypal', 'stripe', 'invoice', 'check', 'cash'
);

-- Invoice status
CREATE TYPE invoice_status AS ENUM (
    'draft', 'sent', 'viewed', 'partially_paid', 'paid', 'overdue', 'cancelled', 'refunded'
);

-- Sales order status
CREATE TYPE sales_order_status AS ENUM (
    'draft', 'pending', 'confirmed', 'processing', 'shipped', 'delivered', 'completed', 'cancelled', 'returned'
);

-- Lead status for CRM
CREATE TYPE lead_status AS ENUM (
    'new', 'contacted', 'qualified', 'proposal', 'negotiation', 'won', 'lost', 'nurturing'
);

-- Opportunity stage
CREATE TYPE opportunity_stage AS ENUM (
    'prospecting', 'qualification', 'proposal', 'negotiation', 'closing', 'won', 'lost'
);

-- Activity types for CRM
CREATE TYPE activity_type AS ENUM (
    'call', 'email', 'meeting', 'task', 'note', 'demo', 'proposal', 'follow_up'
);

-- Document types
CREATE TYPE document_type AS ENUM (
    'contract', 'invoice', 'quote', 'specification', 'manual', 'certificate', 'image', 'spreadsheet', 'presentation', 'other'
);

-- File access levels
CREATE TYPE access_level AS ENUM (
    'private', 'organization', 'team', 'public', 'restricted'
);

-- Communication template types
CREATE TYPE template_type AS ENUM (
    'email', 'sms', 'push_notification', 'in_app', 'letter', 'fax'
);

-- Quality control status
CREATE TYPE qc_status AS ENUM (
    'pending', 'in_progress', 'passed', 'failed', 'requires_retest', 'approved', 'rejected'
);

-- Tax types
CREATE TYPE tax_type AS ENUM (
    'vat', 'sales_tax', 'gst', 'excise', 'customs', 'income_tax', 'property_tax'
);

-- API access scopes
CREATE TYPE api_scope AS ENUM (
    'read', 'write', 'admin', 'integration', 'webhook', 'analytics'
);

-- =====================================================
-- ENHANCED USER MANAGEMENT & AUTHENTICATION
-- =====================================================

-- OAuth providers for authentication
CREATE TABLE oauth_provider (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL UNIQUE,
    client_id text NOT NULL,
    client_secret_encrypted text NOT NULL,
    authorization_url text NOT NULL,
    token_url text NOT NULL,
    user_info_url text NOT NULL,
    scope text DEFAULT 'email profile',
    is_active boolean DEFAULT true,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT oauth_provider_name_length CHECK (char_length(name) >= 2 AND char_length(name) <= 50),
    CONSTRAINT oauth_provider_urls_format CHECK (
        authorization_url ~ '^https://.*' AND
        token_url ~ '^https://.*' AND
        user_info_url ~ '^https://.*'
    )
);

-- API keys for programmatic access
CREATE TABLE api_key (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    key_hash text NOT NULL UNIQUE,
    key_prefix text NOT NULL, -- First 8 chars for identification
    scopes api_scope[] NOT NULL DEFAULT '{read}',
    rate_limit_per_hour integer DEFAULT 1000,
    is_active boolean DEFAULT true,
    last_used_at timestamptz,
    expires_at timestamptz,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT api_key_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 100),
    CONSTRAINT api_key_rate_limit_positive CHECK (rate_limit_per_hour > 0),
    CONSTRAINT api_key_expires_future CHECK (expires_at IS NULL OR expires_at > created_at)
);

-- User sessions for enhanced security tracking
CREATE TABLE user_session (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    session_token_hash text NOT NULL,
    ip_address inet,
    user_agent text,
    device_fingerprint text,
    location_country text,
    location_city text,
    is_active boolean DEFAULT true,
    expires_at timestamptz NOT NULL,
    created_at timestamptz DEFAULT now(),
    last_activity_at timestamptz DEFAULT now(),

    CONSTRAINT session_expires_future CHECK (expires_at > created_at)
);

-- Two-factor authentication
CREATE TABLE user_2fa (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    method text NOT NULL CHECK (method IN ('totp', 'sms', 'email')),
    secret_encrypted text, -- For TOTP
    phone_number text, -- For SMS
    is_verified boolean DEFAULT false,
    backup_codes text[], -- Encrypted backup codes
    created_at timestamptz DEFAULT now(),
    verified_at timestamptz,

    CONSTRAINT user_2fa_unique_method UNIQUE(user_id, method)
);

-- =====================================================
-- COMPREHENSIVE CRM MODULE
-- =====================================================

-- Enhanced customer management (extends existing customer table)
CREATE TABLE customer_contact (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    customer_id uuid NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
    first_name text NOT NULL,
    last_name text NOT NULL,
    title text,
    email text,
    phone text,
    mobile text,
    is_primary boolean DEFAULT false,
    is_active boolean DEFAULT true,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT contact_name_length CHECK (
        char_length(first_name) >= 1 AND char_length(first_name) <= 100 AND
        char_length(last_name) >= 1 AND char_length(last_name) <= 100
    ),
    CONSTRAINT contact_email_format CHECK (email IS NULL OR email ~ '^[^@\s]+@[^@\s]+\.[^@\s]+$')
);

-- Leads management
CREATE TABLE lead (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    first_name text NOT NULL,
    last_name text NOT NULL,
    company text,
    title text,
    email text,
    phone text,
    status lead_status DEFAULT 'new',
    source text, -- e.g., 'website', 'referral', 'cold_call'
    score integer DEFAULT 0, -- Lead scoring 0-100
    assigned_to uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    converted_to_customer_id uuid REFERENCES customer(id) ON DELETE SET NULL,
    converted_at timestamptz,
    estimated_value numeric(12,2) DEFAULT 0,
    expected_close_date date,
    notes text,
    tags text[] DEFAULT '{}',
    custom_fields jsonb DEFAULT '{}',
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT lead_name_length CHECK (
        char_length(first_name) >= 1 AND char_length(first_name) <= 100 AND
        char_length(last_name) >= 1 AND char_length(last_name) <= 100
    ),
    CONSTRAINT lead_score_range CHECK (score >= 0 AND score <= 100),
    CONSTRAINT lead_estimated_value_non_negative CHECK (estimated_value >= 0)
);

-- Sales opportunities
CREATE TABLE opportunity (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    customer_id uuid REFERENCES customer(id) ON DELETE SET NULL,
    lead_id uuid REFERENCES lead(id) ON DELETE SET NULL,
    name text NOT NULL,
    description text,
    stage opportunity_stage DEFAULT 'prospecting',
    amount numeric(12,2) NOT NULL,
    currency currency_code DEFAULT 'USD',
    probability integer DEFAULT 50, -- Win probability 0-100
    assigned_to uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    expected_close_date date,
    actual_close_date date,
    is_won boolean,
    close_reason text,
    competitors text[],
    next_step text,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT opportunity_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 200),
    CONSTRAINT opportunity_amount_positive CHECK (amount > 0),
    CONSTRAINT opportunity_probability_range CHECK (probability >= 0 AND probability <= 100),
    CONSTRAINT opportunity_has_customer_or_lead CHECK (customer_id IS NOT NULL OR lead_id IS NOT NULL)
);

-- CRM activities (calls, meetings, tasks, etc.)
CREATE TABLE crm_activity (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    type activity_type NOT NULL,
    subject text NOT NULL,
    description text,
    customer_id uuid REFERENCES customer(id) ON DELETE CASCADE,
    lead_id uuid REFERENCES lead(id) ON DELETE CASCADE,
    opportunity_id uuid REFERENCES opportunity(id) ON DELETE CASCADE,
    assigned_to uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    due_date timestamptz,
    completed_at timestamptz,
    is_completed boolean DEFAULT false,
    duration_minutes integer,
    outcome text,
    follow_up_required boolean DEFAULT false,
    follow_up_date timestamptz,
    priority integer DEFAULT 3, -- 1=high, 3=medium, 5=low
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT activity_subject_length CHECK (char_length(subject) >= 1 AND char_length(subject) <= 200),
    CONSTRAINT activity_duration_positive CHECK (duration_minutes IS NULL OR duration_minutes > 0),
    CONSTRAINT activity_priority_range CHECK (priority >= 1 AND priority <= 5),
    CONSTRAINT activity_has_relation CHECK (
        customer_id IS NOT NULL OR lead_id IS NOT NULL OR opportunity_id IS NOT NULL
    )
);

-- =====================================================
-- SALES & ORDER MANAGEMENT
-- =====================================================

-- Product catalog (extends inventory_item)
CREATE TABLE product (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    inventory_item_id uuid REFERENCES inventory_item(id) ON DELETE SET NULL,
    name text NOT NULL,
    description text,
    sku text NOT NULL,
    category text,
    brand text,
    model text,
    base_price numeric(10,2) NOT NULL DEFAULT 0,
    cost_price numeric(10,2) DEFAULT 0,
    weight_kg numeric(8,3),
    dimensions_cm text, -- e.g., "10x20x30"
    is_active boolean DEFAULT true,
    is_service boolean DEFAULT false, -- true for services, false for physical products
    tax_category text,
    warranty_months integer DEFAULT 0,
    minimum_quantity integer DEFAULT 1,
    maximum_quantity integer,
    tags text[] DEFAULT '{}',
    images text[] DEFAULT '{}', -- URLs to product images
    custom_fields jsonb DEFAULT '{}',
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT product_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 200),
    CONSTRAINT product_sku_org_unique UNIQUE(org_id, sku),
    CONSTRAINT product_base_price_non_negative CHECK (base_price >= 0),
    CONSTRAINT product_cost_price_non_negative CHECK (cost_price >= 0),
    CONSTRAINT product_weight_positive CHECK (weight_kg IS NULL OR weight_kg > 0),
    CONSTRAINT product_warranty_non_negative CHECK (warranty_months >= 0),
    CONSTRAINT product_min_quantity_positive CHECK (minimum_quantity > 0),
    CONSTRAINT product_max_quantity_valid CHECK (maximum_quantity IS NULL OR maximum_quantity >= minimum_quantity)
);

-- Price lists for different customer segments
CREATE TABLE price_list (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    name text NOT NULL,
    description text,
    currency currency_code DEFAULT 'USD',
    is_default boolean DEFAULT false,
    valid_from date NOT NULL DEFAULT CURRENT_DATE,
    valid_to date,
    customer_segments customer_segment[],
    minimum_order_amount numeric(12,2) DEFAULT 0,
    is_active boolean DEFAULT true,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT price_list_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 200),
    CONSTRAINT price_list_valid_dates CHECK (valid_to IS NULL OR valid_to >= valid_from),
    CONSTRAINT price_list_min_order_non_negative CHECK (minimum_order_amount >= 0)
);

-- Product pricing by price list
CREATE TABLE product_price (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    product_id uuid NOT NULL REFERENCES product(id) ON DELETE CASCADE,
    price_list_id uuid NOT NULL REFERENCES price_list(id) ON DELETE CASCADE,
    unit_price numeric(10,2) NOT NULL,
    discount_percentage numeric(5,2) DEFAULT 0,
    minimum_quantity integer DEFAULT 1,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT product_price_unique UNIQUE(product_id, price_list_id, minimum_quantity),
    CONSTRAINT product_price_unit_price_positive CHECK (unit_price >= 0),
    CONSTRAINT product_price_discount_range CHECK (discount_percentage >= 0 AND discount_percentage <= 100),
    CONSTRAINT product_price_min_quantity_positive CHECK (minimum_quantity > 0)
);

-- Sales quotes/estimates
CREATE TABLE sales_quote (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    customer_id uuid NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
    opportunity_id uuid REFERENCES opportunity(id) ON DELETE SET NULL,
    quote_number text NOT NULL,
    title text NOT NULL,
    description text,
    status sales_order_status DEFAULT 'draft',
    currency currency_code DEFAULT 'USD',
    subtotal numeric(12,2) DEFAULT 0,
    tax_amount numeric(12,2) DEFAULT 0,
    shipping_amount numeric(12,2) DEFAULT 0,
    discount_amount numeric(12,2) DEFAULT 0,
    total_amount numeric(12,2) DEFAULT 0,
    valid_until date,
    terms_and_conditions text,
    internal_notes text,
    created_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    approved_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    approved_at timestamptz,
    converted_to_order_id uuid,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT quote_number_org_unique UNIQUE(org_id, quote_number),
    CONSTRAINT quote_title_length CHECK (char_length(title) >= 1 AND char_length(title) <= 200),
    CONSTRAINT quote_amounts_non_negative CHECK (
        subtotal >= 0 AND tax_amount >= 0 AND shipping_amount >= 0 AND
        discount_amount >= 0 AND total_amount >= 0
    ),
    CONSTRAINT quote_valid_until_future CHECK (valid_until IS NULL OR valid_until >= CURRENT_DATE)
);

-- Quote line items
CREATE TABLE sales_quote_item (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    quote_id uuid NOT NULL REFERENCES sales_quote(id) ON DELETE CASCADE,
    product_id uuid NOT NULL REFERENCES product(id) ON DELETE RESTRICT,
    description text,
    quantity numeric(10,3) NOT NULL,
    unit_price numeric(10,2) NOT NULL,
    discount_percentage numeric(5,2) DEFAULT 0,
    line_total numeric(12,2) GENERATED ALWAYS AS (
        quantity * unit_price * (1 - discount_percentage/100)
    ) STORED,
    tax_rate numeric(5,2) DEFAULT 0,
    notes text,
    created_at timestamptz DEFAULT now(),

    CONSTRAINT quote_item_quantity_positive CHECK (quantity > 0),
    CONSTRAINT quote_item_unit_price_non_negative CHECK (unit_price >= 0),
    CONSTRAINT quote_item_discount_range CHECK (discount_percentage >= 0 AND discount_percentage <= 100),
    CONSTRAINT quote_item_tax_rate_non_negative CHECK (tax_rate >= 0)
);

-- Sales orders
CREATE TABLE sales_order (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    customer_id uuid NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
    quote_id uuid REFERENCES sales_quote(id) ON DELETE SET NULL,
    order_number text NOT NULL,
    status sales_order_status DEFAULT 'draft',
    currency currency_code DEFAULT 'USD',
    subtotal numeric(12,2) DEFAULT 0,
    tax_amount numeric(12,2) DEFAULT 0,
    shipping_amount numeric(12,2) DEFAULT 0,
    discount_amount numeric(12,2) DEFAULT 0,
    total_amount numeric(12,2) DEFAULT 0,
    order_date date DEFAULT CURRENT_DATE,
    requested_delivery_date date,
    promised_delivery_date date,
    actual_delivery_date date,
    shipping_address jsonb,
    billing_address jsonb,
    payment_terms text DEFAULT 'Net 30',
    created_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    approved_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    approved_at timestamptz,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT order_number_org_unique UNIQUE(org_id, order_number),
    CONSTRAINT order_amounts_non_negative CHECK (
        subtotal >= 0 AND tax_amount >= 0 AND shipping_amount >= 0 AND
        discount_amount >= 0 AND total_amount >= 0
    ),
    CONSTRAINT order_delivery_dates_logical CHECK (
        (requested_delivery_date IS NULL OR requested_delivery_date >= order_date) AND
        (promised_delivery_date IS NULL OR promised_delivery_date >= order_date) AND
        (actual_delivery_date IS NULL OR actual_delivery_date >= order_date)
    )
);

-- Sales order line items
CREATE TABLE sales_order_item (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id uuid NOT NULL REFERENCES sales_order(id) ON DELETE CASCADE,
    product_id uuid NOT NULL REFERENCES product(id) ON DELETE RESTRICT,
    description text,
    quantity numeric(10,3) NOT NULL,
    unit_price numeric(10,2) NOT NULL,
    discount_percentage numeric(5,2) DEFAULT 0,
    line_total numeric(12,2) GENERATED ALWAYS AS (
        quantity * unit_price * (1 - discount_percentage/100)
    ) STORED,
    tax_rate numeric(5,2) DEFAULT 0,
    quantity_shipped numeric(10,3) DEFAULT 0,
    quantity_invoiced numeric(10,3) DEFAULT 0,
    notes text,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT order_item_quantity_positive CHECK (quantity > 0),
    CONSTRAINT order_item_unit_price_non_negative CHECK (unit_price >= 0),
    CONSTRAINT order_item_discount_range CHECK (discount_percentage >= 0 AND discount_percentage <= 100),
    CONSTRAINT order_item_tax_rate_non_negative CHECK (tax_rate >= 0),
    CONSTRAINT order_item_shipped_not_exceed CHECK (quantity_shipped <= quantity),
    CONSTRAINT order_item_invoiced_not_exceed CHECK (quantity_invoiced <= quantity)
);

-- =====================================================
-- FINANCIAL MANAGEMENT
-- =====================================================

-- Chart of accounts
CREATE TABLE account (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    code text NOT NULL,
    name text NOT NULL,
    account_type text NOT NULL, -- 'asset', 'liability', 'equity', 'income', 'expense'
    parent_account_id uuid REFERENCES account(id) ON DELETE SET NULL,
    description text,
    is_active boolean DEFAULT true,
    normal_balance text NOT NULL CHECK (normal_balance IN ('debit', 'credit')),
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT account_code_org_unique UNIQUE(org_id, code),
    CONSTRAINT account_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 200),
    CONSTRAINT account_type_valid CHECK (account_type IN ('asset', 'liability', 'equity', 'income', 'expense'))
);

-- Tax configurations
CREATE TABLE tax_rate (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    name text NOT NULL,
    tax_type tax_type NOT NULL,
    rate numeric(5,4) NOT NULL, -- e.g., 0.0825 for 8.25%
    is_compound boolean DEFAULT false, -- Tax on tax
    is_active boolean DEFAULT true,
    effective_from date NOT NULL DEFAULT CURRENT_DATE,
    effective_to date,
    jurisdiction text, -- State, province, country
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT tax_rate_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 100),
    CONSTRAINT tax_rate_rate_non_negative CHECK (rate >= 0),
    CONSTRAINT tax_rate_effective_dates CHECK (effective_to IS NULL OR effective_to >= effective_from)
);

-- Invoices
CREATE TABLE invoice (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    customer_id uuid NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
    sales_order_id uuid REFERENCES sales_order(id) ON DELETE SET NULL,
    invoice_number text NOT NULL,
    status invoice_status DEFAULT 'draft',
    currency currency_code DEFAULT 'USD',
    subtotal numeric(12,2) DEFAULT 0,
    tax_amount numeric(12,2) DEFAULT 0,
    discount_amount numeric(12,2) DEFAULT 0,
    total_amount numeric(12,2) DEFAULT 0,
    amount_paid numeric(12,2) DEFAULT 0,
    amount_due numeric(12,2) GENERATED ALWAYS AS (total_amount - amount_paid) STORED,
    invoice_date date DEFAULT CURRENT_DATE,
    due_date date NOT NULL,
    payment_terms text DEFAULT 'Net 30',
    billing_address jsonb,
    notes text,
    sent_at timestamptz,
    viewed_at timestamptz,
    first_payment_at timestamptz,
    created_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT invoice_number_org_unique UNIQUE(org_id, invoice_number),
    CONSTRAINT invoice_amounts_non_negative CHECK (
        subtotal >= 0 AND tax_amount >= 0 AND discount_amount >= 0 AND
        total_amount >= 0 AND amount_paid >= 0
    ),
    CONSTRAINT invoice_due_date_after_invoice CHECK (due_date >= invoice_date),
    CONSTRAINT invoice_amount_paid_not_exceed CHECK (amount_paid <= total_amount)
);

-- Invoice line items
CREATE TABLE invoice_item (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    invoice_id uuid NOT NULL REFERENCES invoice(id) ON DELETE CASCADE,
    product_id uuid REFERENCES product(id) ON DELETE SET NULL,
    description text NOT NULL,
    quantity numeric(10,3) NOT NULL,
    unit_price numeric(10,2) NOT NULL,
    discount_percentage numeric(5,2) DEFAULT 0,
    line_total numeric(12,2) GENERATED ALWAYS AS (
        quantity * unit_price * (1 - discount_percentage/100)
    ) STORED,
    tax_rate numeric(5,2) DEFAULT 0,
    created_at timestamptz DEFAULT now(),

    CONSTRAINT invoice_item_description_not_empty CHECK (char_length(description) > 0),
    CONSTRAINT invoice_item_quantity_positive CHECK (quantity > 0),
    CONSTRAINT invoice_item_unit_price_non_negative CHECK (unit_price >= 0),
    CONSTRAINT invoice_item_discount_range CHECK (discount_percentage >= 0 AND discount_percentage <= 100),
    CONSTRAINT invoice_item_tax_rate_non_negative CHECK (tax_rate >= 0)
);

-- Payment records
CREATE TABLE payment (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    customer_id uuid NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
    invoice_id uuid REFERENCES invoice(id) ON DELETE SET NULL,
    payment_number text NOT NULL,
    amount numeric(12,2) NOT NULL,
    currency currency_code DEFAULT 'USD',
    payment_method payment_method NOT NULL,
    status payment_status DEFAULT 'pending',
    payment_date date DEFAULT CURRENT_DATE,
    reference_number text, -- Check number, transaction ID, etc.
    gateway_transaction_id text, -- Stripe, PayPal transaction ID
    gateway_response jsonb, -- Full gateway response
    notes text,
    processed_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT payment_number_org_unique UNIQUE(org_id, payment_number),
    CONSTRAINT payment_amount_positive CHECK (amount > 0)
);

-- General ledger entries
CREATE TABLE journal_entry (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    entry_number text NOT NULL,
    description text NOT NULL,
    entry_date date DEFAULT CURRENT_DATE,
    reference_type text, -- 'invoice', 'payment', 'adjustment', etc.
    reference_id uuid, -- ID of the related record
    total_debits numeric(15,2) DEFAULT 0,
    total_credits numeric(15,2) DEFAULT 0,
    is_posted boolean DEFAULT false,
    posted_at timestamptz,
    posted_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),

    CONSTRAINT journal_entry_number_org_unique UNIQUE(org_id, entry_number),
    CONSTRAINT journal_entry_description_not_empty CHECK (char_length(description) > 0),
    CONSTRAINT journal_entry_debits_credits_equal CHECK (
        NOT is_posted OR total_debits = total_credits
    )
);

-- Journal entry line items
CREATE TABLE journal_entry_line (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    journal_entry_id uuid NOT NULL REFERENCES journal_entry(id) ON DELETE CASCADE,
    account_id uuid NOT NULL REFERENCES account(id) ON DELETE RESTRICT,
    description text,
    debit_amount numeric(15,2) DEFAULT 0,
    credit_amount numeric(15,2) DEFAULT 0,
    line_number integer NOT NULL,
    created_at timestamptz DEFAULT now(),

    CONSTRAINT journal_line_amounts_non_negative CHECK (debit_amount >= 0 AND credit_amount >= 0),
    CONSTRAINT journal_line_amount_exclusive CHECK (
        (debit_amount > 0 AND credit_amount = 0) OR
        (debit_amount = 0 AND credit_amount > 0)
    ),
    CONSTRAINT journal_line_unique_line_number UNIQUE(journal_entry_id, line_number)
);

-- =====================================================
-- ENHANCED SUPPLY CHAIN & PROCUREMENT
-- =====================================================

-- Supplier performance tracking
CREATE TABLE supplier_performance (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id uuid NOT NULL REFERENCES supplier(id) ON DELETE CASCADE,
    evaluation_period_start date NOT NULL,
    evaluation_period_end date NOT NULL,
    quality_score integer, -- 0-100
    delivery_score integer, -- 0-100
    cost_score integer, -- 0-100
    overall_score integer, -- 0-100
    orders_count integer DEFAULT 0,
    on_time_deliveries integer DEFAULT 0,
    quality_issues integer DEFAULT 0,
    total_spend numeric(15,2) DEFAULT 0,
    evaluator_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    notes text,
    created_at timestamptz DEFAULT now(),

    CONSTRAINT supplier_perf_period_valid CHECK (evaluation_period_end >= evaluation_period_start),
    CONSTRAINT supplier_perf_scores_range CHECK (
        (quality_score IS NULL OR (quality_score >= 0 AND quality_score <= 100)) AND
        (delivery_score IS NULL OR (delivery_score >= 0 AND delivery_score <= 100)) AND
        (cost_score IS NULL OR (cost_score >= 0 AND cost_score <= 100)) AND
        (overall_score IS NULL OR (overall_score >= 0 AND overall_score <= 100))
    ),
    CONSTRAINT supplier_perf_counts_non_negative CHECK (
        orders_count >= 0 AND on_time_deliveries >= 0 AND quality_issues >= 0 AND total_spend >= 0
    )
);

-- Quality control checks
CREATE TABLE quality_control (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    purchase_order_id uuid REFERENCES purchase_order(id) ON DELETE SET NULL,
    inventory_item_id uuid NOT NULL REFERENCES inventory_item(id) ON DELETE CASCADE,
    batch_number text,
    serial_number text,
    inspection_date date DEFAULT CURRENT_DATE,
    inspector_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    status qc_status DEFAULT 'pending',
    test_results jsonb DEFAULT '{}', -- Flexible test result storage
    defects_found text[],
    corrective_actions text[],
    approved_quantity integer DEFAULT 0,
    rejected_quantity integer DEFAULT 0,
    rework_quantity integer DEFAULT 0,
    notes text,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT qc_quantities_non_negative CHECK (
        approved_quantity >= 0 AND rejected_quantity >= 0 AND rework_quantity >= 0
    )
);

-- =====================================================
-- DOCUMENT MANAGEMENT SYSTEM
-- =====================================================

-- Document storage with versioning
CREATE TABLE document (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    name text NOT NULL,
    description text,
    file_name text NOT NULL,
    file_size_bytes bigint NOT NULL,
    mime_type text NOT NULL,
    file_hash text NOT NULL, -- SHA-256 hash for deduplication
    storage_path text NOT NULL, -- S3 key or file path
    document_type document_type DEFAULT 'other',
    access_level access_level DEFAULT 'organization',
    version_number integer DEFAULT 1,
    parent_document_id uuid REFERENCES document(id) ON DELETE SET NULL,
    is_current_version boolean DEFAULT true,
    tags text[] DEFAULT '{}',
    metadata jsonb DEFAULT '{}',
    uploaded_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT document_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 200),
    CONSTRAINT document_file_size_positive CHECK (file_size_bytes > 0),
    CONSTRAINT document_version_positive CHECK (version_number > 0)
);

-- Document permissions
CREATE TABLE document_permission (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id uuid NOT NULL REFERENCES document(id) ON DELETE CASCADE,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    role user_role,
    permission_type text NOT NULL CHECK (permission_type IN ('read', 'write', 'delete', 'share')),
    granted_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    granted_at timestamptz DEFAULT now(),
    expires_at timestamptz,

    CONSTRAINT doc_perm_user_or_role CHECK (user_id IS NOT NULL OR role IS NOT NULL),
    CONSTRAINT doc_perm_expires_future CHECK (expires_at IS NULL OR expires_at > granted_at),
    CONSTRAINT doc_perm_unique UNIQUE(document_id, user_id, role, permission_type)
);

-- Document access log
CREATE TABLE document_access_log (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id uuid NOT NULL REFERENCES document(id) ON DELETE CASCADE,
    user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    action text NOT NULL, -- 'view', 'download', 'edit', 'delete', 'share'
    ip_address inet,
    user_agent text,
    accessed_at timestamptz DEFAULT now(),

    CONSTRAINT doc_access_action_valid CHECK (action IN ('view', 'download', 'edit', 'delete', 'share'))
);

-- =====================================================
-- COMMUNICATION & NOTIFICATION SYSTEM
-- =====================================================

-- Email/SMS templates
CREATE TABLE communication_template (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    name text NOT NULL,
    description text,
    template_type template_type NOT NULL,
    subject text, -- For emails
    content text NOT NULL,
    variables text[] DEFAULT '{}', -- {{customer_name}}, {{order_number}}, etc.
    is_active boolean DEFAULT true,
    usage_count integer DEFAULT 0,
    created_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT comm_template_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 200),
    CONSTRAINT comm_template_content_not_empty CHECK (char_length(content) > 0),
    CONSTRAINT comm_template_usage_count_non_negative CHECK (usage_count >= 0)
);

-- Communication campaigns
CREATE TABLE communication_campaign (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    name text NOT NULL,
    description text,
    template_id uuid NOT NULL REFERENCES communication_template(id) ON DELETE RESTRICT,
    target_audience jsonb DEFAULT '{}', -- Query criteria for recipients
    scheduled_at timestamptz,
    sent_at timestamptz,
    status text DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'sending', 'sent', 'cancelled')),
    total_recipients integer DEFAULT 0,
    successful_sends integer DEFAULT 0,
    failed_sends integer DEFAULT 0,
    created_by uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),

    CONSTRAINT campaign_name_length CHECK (char_length(name) >= 1 AND char_length(name) <= 200),
    CONSTRAINT campaign_counts_non_negative CHECK (
        total_recipients >= 0 AND successful_sends >= 0 AND failed_sends >= 0
    ),
    CONSTRAINT campaign_scheduled_future CHECK (
        scheduled_at IS NULL OR scheduled_at > created_at
    )
);

-- Individual communication records (partitioned)
CREATE TABLE communication_log (
    id uuid DEFAULT gen_random_uuid(),
    org_id uuid NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    campaign_id uuid REFERENCES communication_campaign(id) ON DELETE SET NULL,
    recipient_type text NOT NULL, -- 'customer', 'user', 'lead'
    recipient_id uuid NOT NULL,
    recipient_email text,
    recipient_phone text,
    template_id uuid REFERENCES communication_template(id) ON DELETE SET NULL,
    subject text,
    content text NOT NULL,
    status text DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'delivered', 'failed', 'bounced')),
    error_message text,
    external_id text, -- Provider message ID (SendGrid, Twilio, etc.)
    sent_at timestamptz DEFAULT now(),
    delivered_at timestamptz,
    opened_at timestamptz,
    clicked_at timestamptz,

    PRIMARY KEY (id, sent_at),
    CONSTRAINT comm_log_content_not_empty CHECK (char_length(content) > 0),
    CONSTRAINT comm_log_recipient_contact CHECK (recipient_email IS NOT NULL OR recipient_phone IS NOT NULL)
) PARTITION BY RANGE (sent_at);

-- Communication log partitions
CREATE TABLE communication_log_2024_q4 PARTITION OF communication_log
    FOR VALUES FROM ('2024-10-01') TO ('2025-01-01');
CREATE TABLE communication_log_2025_q1 PARTITION OF communication_log
    FOR VALUES FROM ('2025-01-01') TO ('2025-04-01');
CREATE TABLE communication_log_2025_q2 PARTITION OF communication_log
    FOR VALUES FROM ('2025-04-01') TO ('2025-07-01');
CREATE TABLE communication_log_2025_q3 PARTITION OF communication_log
    FOR VALUES FROM ('2025-07-01') TO ('2025-10-01');

-- =====================================================
-- ENHANCED ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS on all new tables
ALTER TABLE oauth_provider ENABLE ROW LEVEL SECURITY;
ALTER TABLE api_key ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_session ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_2fa ENABLE ROW LEVEL SECURITY;
ALTER TABLE customer_contact ENABLE ROW LEVEL SECURITY;
ALTER TABLE lead ENABLE ROW LEVEL SECURITY;
ALTER TABLE opportunity ENABLE ROW LEVEL SECURITY;
ALTER TABLE crm_activity ENABLE ROW LEVEL SECURITY;
ALTER TABLE product ENABLE ROW LEVEL SECURITY;
ALTER TABLE price_list ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_price ENABLE ROW LEVEL SECURITY;
ALTER TABLE sales_quote ENABLE ROW LEVEL SECURITY;
ALTER TABLE sales_quote_item ENABLE ROW LEVEL SECURITY;
ALTER TABLE sales_order ENABLE ROW LEVEL SECURITY;
ALTER TABLE sales_order_item ENABLE ROW LEVEL SECURITY;
ALTER TABLE account ENABLE ROW LEVEL SECURITY;
ALTER TABLE tax_rate ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoice ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoice_item ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment ENABLE ROW LEVEL SECURITY;
ALTER TABLE journal_entry ENABLE ROW LEVEL SECURITY;
ALTER TABLE journal_entry_line ENABLE ROW LEVEL SECURITY;
ALTER TABLE supplier_performance ENABLE ROW LEVEL SECURITY;
ALTER TABLE quality_control ENABLE ROW LEVEL SECURITY;
ALTER TABLE document ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_permission ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_access_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE communication_template ENABLE ROW LEVEL SECURITY;
ALTER TABLE communication_campaign ENABLE ROW LEVEL SECURITY;

-- Multi-tenant RLS policies - Users can only see data from their organization
CREATE POLICY tenant_isolation ON api_key
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON customer_contact
    USING (
        (SELECT org_id FROM customer WHERE id = customer_contact.customer_id) =
        (SELECT org_id FROM profile WHERE id = auth.uid())
    );

CREATE POLICY tenant_isolation ON lead
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON opportunity
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON crm_activity
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON product
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON price_list
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON sales_quote
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON sales_order
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON account
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON tax_rate
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON invoice
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON payment
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON journal_entry
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON quality_control
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON document
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON communication_template
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

CREATE POLICY tenant_isolation ON communication_campaign
    USING (org_id = (SELECT org_id FROM profile WHERE id = auth.uid()));

-- Role-based access policies
CREATE POLICY admin_full_access ON api_key
    TO admin
    USING (true)
    WITH CHECK (true);

CREATE POLICY financial_data_access ON invoice
    USING (
        org_id = (SELECT org_id FROM profile WHERE id = auth.uid()) AND
        (SELECT role FROM profile WHERE id = auth.uid()) IN ('admin', 'ops_manager', 'exec')
    );

CREATE POLICY financial_data_access ON payment
    USING (
        org_id = (SELECT org_id FROM profile WHERE id = auth.uid()) AND
        (SELECT role FROM profile WHERE id = auth.uid()) IN ('admin', 'ops_manager', 'exec')
    );

CREATE POLICY financial_data_access ON journal_entry
    USING (
        org_id = (SELECT org_id FROM profile WHERE id = auth.uid()) AND
        (SELECT role FROM profile WHERE id = auth.uid()) IN ('admin', 'ops_manager', 'exec')
    );

-- Document access policies with permission checks
CREATE POLICY document_access_policy ON document
    USING (
        org_id = (SELECT org_id FROM profile WHERE id = auth.uid()) AND
        (
            -- Owner can always access
            uploaded_by = auth.uid() OR
            -- Admin can access all org documents
            (SELECT role FROM profile WHERE id = auth.uid()) = 'admin' OR
            -- Check explicit permissions
            EXISTS (
                SELECT 1 FROM document_permission dp
                WHERE dp.document_id = document.id
                AND (
                    dp.user_id = auth.uid() OR
                    dp.role = (SELECT role FROM profile WHERE id = auth.uid())
                )
                AND dp.permission_type = 'read'
                AND (dp.expires_at IS NULL OR dp.expires_at > now())
            ) OR
            -- Check access level
            (
                access_level = 'public' OR
                (access_level = 'organization' AND org_id = (SELECT org_id FROM profile WHERE id = auth.uid()))
            )
        )
    );

-- =====================================================
-- PERFORMANCE INDEXES
-- =====================================================

-- Authentication & User Management indexes
CREATE INDEX idx_oauth_provider_name ON oauth_provider(name);
CREATE INDEX idx_api_key_org_user ON api_key(org_id, user_id);
CREATE INDEX idx_api_key_prefix ON api_key(key_prefix);
CREATE INDEX idx_api_key_active ON api_key(is_active) WHERE is_active = true;
CREATE INDEX idx_user_session_user_active ON user_session(user_id, is_active) WHERE is_active = true;
CREATE INDEX idx_user_session_expires ON user_session(expires_at);
CREATE INDEX idx_user_2fa_user_method ON user_2fa(user_id, method);

-- CRM indexes
CREATE INDEX idx_customer_contact_customer ON customer_contact(customer_id);
CREATE INDEX idx_customer_contact_email ON customer_contact(email) WHERE email IS NOT NULL;
CREATE INDEX idx_customer_contact_primary ON customer_contact(customer_id, is_primary) WHERE is_primary = true;

CREATE INDEX idx_lead_org_status ON lead(org_id, status);
CREATE INDEX idx_lead_assigned_to ON lead(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX idx_lead_score ON lead(score DESC);
CREATE INDEX idx_lead_email ON lead(email) WHERE email IS NOT NULL;
CREATE INDEX idx_lead_company ON lead(company) WHERE company IS NOT NULL;
CREATE INDEX idx_lead_converted ON lead(converted_to_customer_id) WHERE converted_to_customer_id IS NOT NULL;
CREATE INDEX idx_lead_search ON lead USING gin(to_tsvector('english',
    first_name || ' ' || last_name || ' ' || COALESCE(company, '') || ' ' || COALESCE(email, '')));

CREATE INDEX idx_opportunity_org_stage ON opportunity(org_id, stage);
CREATE INDEX idx_opportunity_customer ON opportunity(customer_id) WHERE customer_id IS NOT NULL;
CREATE INDEX idx_opportunity_lead ON opportunity(lead_id) WHERE lead_id IS NOT NULL;
CREATE INDEX idx_opportunity_assigned_to ON opportunity(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX idx_opportunity_amount ON opportunity(amount DESC);
CREATE INDEX idx_opportunity_probability ON opportunity(probability DESC);
CREATE INDEX idx_opportunity_close_date ON opportunity(expected_close_date);

CREATE INDEX idx_crm_activity_org_type ON crm_activity(org_id, type);
CREATE INDEX idx_crm_activity_customer ON crm_activity(customer_id) WHERE customer_id IS NOT NULL;
CREATE INDEX idx_crm_activity_lead ON crm_activity(lead_id) WHERE lead_id IS NOT NULL;
CREATE INDEX idx_crm_activity_opportunity ON crm_activity(opportunity_id) WHERE opportunity_id IS NOT NULL;
CREATE INDEX idx_crm_activity_assigned_to ON crm_activity(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX idx_crm_activity_due_date ON crm_activity(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX idx_crm_activity_completed ON crm_activity(is_completed);

-- Product & Sales indexes
CREATE INDEX idx_product_org_active ON product(org_id, is_active) WHERE is_active = true;
CREATE INDEX idx_product_sku ON product(org_id, sku);
CREATE INDEX idx_product_category ON product(category) WHERE category IS NOT NULL;
CREATE INDEX idx_product_inventory_item ON product(inventory_item_id) WHERE inventory_item_id IS NOT NULL;
CREATE INDEX idx_product_search ON product USING gin(to_tsvector('english',
    name || ' ' || COALESCE(description, '') || ' ' || sku || ' ' || COALESCE(brand, '')));

CREATE INDEX idx_price_list_org_active ON price_list(org_id, is_active) WHERE is_active = true;
CREATE INDEX idx_price_list_default ON price_list(org_id, is_default) WHERE is_default = true;
CREATE INDEX idx_price_list_valid_dates ON price_list(valid_from, valid_to);

CREATE INDEX idx_product_price_product_list ON product_price(product_id, price_list_id);
CREATE INDEX idx_product_price_min_quantity ON product_price(minimum_quantity);

CREATE INDEX idx_sales_quote_org_status ON sales_quote(org_id, status);
CREATE INDEX idx_sales_quote_customer ON sales_quote(customer_id);
CREATE INDEX idx_sales_quote_opportunity ON sales_quote(opportunity_id) WHERE opportunity_id IS NOT NULL;
CREATE INDEX idx_sales_quote_number ON sales_quote(org_id, quote_number);
CREATE INDEX idx_sales_quote_valid_until ON sales_quote(valid_until) WHERE valid_until IS NOT NULL;
CREATE INDEX idx_sales_quote_created_by ON sales_quote(created_by);

CREATE INDEX idx_sales_quote_item_quote ON sales_quote_item(quote_id);
CREATE INDEX idx_sales_quote_item_product ON sales_quote_item(product_id);

CREATE INDEX idx_sales_order_org_status ON sales_order(org_id, status);
CREATE INDEX idx_sales_order_customer ON sales_order(customer_id);
CREATE INDEX idx_sales_order_quote ON sales_order(quote_id) WHERE quote_id IS NOT NULL;
CREATE INDEX idx_sales_order_number ON sales_order(org_id, order_number);
CREATE INDEX idx_sales_order_dates ON sales_order(order_date, requested_delivery_date);
CREATE INDEX idx_sales_order_created_by ON sales_order(created_by);

CREATE INDEX idx_sales_order_item_order ON sales_order_item(order_id);
CREATE INDEX idx_sales_order_item_product ON sales_order_item(product_id);

-- Financial indexes
CREATE INDEX idx_account_org_type ON account(org_id, account_type);
CREATE INDEX idx_account_code ON account(org_id, code);
CREATE INDEX idx_account_parent ON account(parent_account_id) WHERE parent_account_id IS NOT NULL;
CREATE INDEX idx_account_active ON account(org_id, is_active) WHERE is_active = true;

CREATE INDEX idx_tax_rate_org_active ON tax_rate(org_id, is_active) WHERE is_active = true;
CREATE INDEX idx_tax_rate_type ON tax_rate(tax_type);
CREATE INDEX idx_tax_rate_effective_dates ON tax_rate(effective_from, effective_to);

CREATE INDEX idx_invoice_org_status ON invoice(org_id, status);
CREATE INDEX idx_invoice_customer ON invoice(customer_id);
CREATE INDEX idx_invoice_sales_order ON invoice(sales_order_id) WHERE sales_order_id IS NOT NULL;
CREATE INDEX idx_invoice_number ON invoice(org_id, invoice_number);
CREATE INDEX idx_invoice_due_date ON invoice(due_date);
CREATE INDEX idx_invoice_overdue ON invoice(due_date, status)
    WHERE status NOT IN ('paid', 'cancelled', 'refunded') AND due_date < CURRENT_DATE;
CREATE INDEX idx_invoice_created_by ON invoice(created_by);

CREATE INDEX idx_invoice_item_invoice ON invoice_item(invoice_id);
CREATE INDEX idx_invoice_item_product ON invoice_item(product_id) WHERE product_id IS NOT NULL;

CREATE INDEX idx_payment_org_status ON payment(org_id, status);
CREATE INDEX idx_payment_customer ON payment(customer_id);
CREATE INDEX idx_payment_invoice ON payment(invoice_id) WHERE invoice_id IS NOT NULL;
CREATE INDEX idx_payment_number ON payment(org_id, payment_number);
CREATE INDEX idx_payment_method ON payment(payment_method);
CREATE INDEX idx_payment_date ON payment(payment_date);
CREATE INDEX idx_payment_gateway_txn ON payment(gateway_transaction_id) WHERE gateway_transaction_id IS NOT NULL;

CREATE INDEX idx_journal_entry_org_date ON journal_entry(org_id, entry_date DESC);
CREATE INDEX idx_journal_entry_number ON journal_entry(org_id, entry_number);
CREATE INDEX idx_journal_entry_reference ON journal_entry(reference_type, reference_id)
    WHERE reference_type IS NOT NULL AND reference_id IS NOT NULL;
CREATE INDEX idx_journal_entry_posted ON journal_entry(is_posted);

CREATE INDEX idx_journal_entry_line_entry ON journal_entry_line(journal_entry_id, line_number);
CREATE INDEX idx_journal_entry_line_account ON journal_entry_line(account_id);

-- Supply Chain indexes
CREATE INDEX idx_supplier_performance_supplier_period ON supplier_performance(supplier_id, evaluation_period_start, evaluation_period_end);
CREATE INDEX idx_supplier_performance_overall_score ON supplier_performance(overall_score DESC) WHERE overall_score IS NOT NULL;

CREATE INDEX idx_quality_control_org_date ON quality_control(org_id, inspection_date DESC);
CREATE INDEX idx_quality_control_purchase_order ON quality_control(purchase_order_id) WHERE purchase_order_id IS NOT NULL;
CREATE INDEX idx_quality_control_inventory_item ON quality_control(inventory_item_id);
CREATE INDEX idx_quality_control_status ON quality_control(status);
CREATE INDEX idx_quality_control_inspector ON quality_control(inspector_id);
CREATE INDEX idx_quality_control_batch ON quality_control(batch_number) WHERE batch_number IS NOT NULL;

-- Document Management indexes
CREATE INDEX idx_document_org_type ON document(org_id, document_type);
CREATE INDEX idx_document_uploaded_by ON document(uploaded_by);
CREATE INDEX idx_document_access_level ON document(access_level);
CREATE INDEX idx_document_current_version ON document(parent_document_id, is_current_version) WHERE is_current_version = true;
CREATE INDEX idx_document_file_hash ON document(file_hash);
CREATE INDEX idx_document_search ON document USING gin(to_tsvector('english',
    name || ' ' || COALESCE(description, '')));

CREATE INDEX idx_document_permission_document_user ON document_permission(document_id, user_id);
CREATE INDEX idx_document_permission_document_role ON document_permission(document_id, role);
CREATE INDEX idx_document_permission_expires ON document_permission(expires_at) WHERE expires_at IS NOT NULL;

CREATE INDEX idx_document_access_log_document_time ON document_access_log(document_id, accessed_at DESC);
CREATE INDEX idx_document_access_log_user_time ON document_access_log(user_id, accessed_at DESC) WHERE user_id IS NOT NULL;
CREATE INDEX idx_document_access_log_action ON document_access_log(action);

-- Communication indexes
CREATE INDEX idx_communication_template_org_type ON communication_template(org_id, template_type);
CREATE INDEX idx_communication_template_active ON communication_template(org_id, is_active) WHERE is_active = true;
CREATE INDEX idx_communication_template_usage ON communication_template(usage_count DESC);

CREATE INDEX idx_communication_campaign_org_status ON communication_campaign(org_id, status);
CREATE INDEX idx_communication_campaign_scheduled ON communication_campaign(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX idx_communication_campaign_template ON communication_campaign(template_id);

-- Communication log partition indexes
CREATE INDEX idx_communication_log_2024_q4_org ON communication_log_2024_q4(org_id, sent_at DESC);
CREATE INDEX idx_communication_log_2024_q4_campaign ON communication_log_2024_q4(campaign_id, sent_at DESC) WHERE campaign_id IS NOT NULL;
CREATE INDEX idx_communication_log_2024_q4_recipient ON communication_log_2024_q4(recipient_type, recipient_id);
CREATE INDEX idx_communication_log_2024_q4_status ON communication_log_2024_q4(status);

CREATE INDEX idx_communication_log_2025_q1_org ON communication_log_2025_q1(org_id, sent_at DESC);
CREATE INDEX idx_communication_log_2025_q1_campaign ON communication_log_2025_q1(campaign_id, sent_at DESC) WHERE campaign_id IS NOT NULL;
CREATE INDEX idx_communication_log_2025_q1_recipient ON communication_log_2025_q1(recipient_type, recipient_id);
CREATE INDEX idx_communication_log_2025_q1_status ON communication_log_2025_q1(status);

CREATE INDEX idx_communication_log_2025_q2_org ON communication_log_2025_q2(org_id, sent_at DESC);
CREATE INDEX idx_communication_log_2025_q2_campaign ON communication_log_2025_q2(campaign_id, sent_at DESC) WHERE campaign_id IS NOT NULL;
CREATE INDEX idx_communication_log_2025_q2_recipient ON communication_log_2025_q2(recipient_type, recipient_id);
CREATE INDEX idx_communication_log_2025_q2_status ON communication_log_2025_q2(status);

CREATE INDEX idx_communication_log_2025_q3_org ON communication_log_2025_q3(org_id, sent_at DESC);
CREATE INDEX idx_communication_log_2025_q3_campaign ON communication_log_2025_q3(campaign_id, sent_at DESC) WHERE campaign_id IS NOT NULL;
CREATE INDEX idx_communication_log_2025_q3_recipient ON communication_log_2025_q3(recipient_type, recipient_id);
CREATE INDEX idx_communication_log_2025_q3_status ON communication_log_2025_q3(status);

-- =====================================================
-- ENHANCED TRIGGER FUNCTIONS
-- =====================================================

-- Auto-update quote/order totals when line items change
CREATE OR REPLACE FUNCTION update_quote_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE sales_quote
    SET
        subtotal = (
            SELECT COALESCE(SUM(line_total), 0)
            FROM sales_quote_item
            WHERE quote_id = COALESCE(NEW.quote_id, OLD.quote_id)
        ),
        total_amount = subtotal + tax_amount + shipping_amount - discount_amount
    WHERE id = COALESCE(NEW.quote_id, OLD.quote_id);

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE sales_order
    SET
        subtotal = (
            SELECT COALESCE(SUM(line_total), 0)
            FROM sales_order_item
            WHERE order_id = COALESCE(NEW.order_id, OLD.order_id)
        ),
        total_amount = subtotal + tax_amount + shipping_amount - discount_amount
    WHERE id = COALESCE(NEW.order_id, OLD.order_id);

    RETURN COALESCE(NEW, order);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION update_invoice_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE invoice
    SET
        subtotal = (
            SELECT COALESCE(SUM(line_total), 0)
            FROM invoice_item
            WHERE invoice_id = COALESCE(NEW.invoice_id, OLD.invoice_id)
        ),
        total_amount = subtotal + tax_amount - discount_amount
    WHERE id = COALESCE(NEW.invoice_id, OLD.invoice_id);

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Update invoice payment status when payments are recorded
CREATE OR REPLACE FUNCTION update_invoice_payment_status()
RETURNS TRIGGER AS $$
DECLARE
    invoice_total numeric;
    total_payments numeric;
    new_status invoice_status;
BEGIN
    IF NEW.invoice_id IS NOT NULL THEN
        -- Get invoice total and sum of all payments
        SELECT total_amount INTO invoice_total
        FROM invoice WHERE id = NEW.invoice_id;

        SELECT COALESCE(SUM(amount), 0) INTO total_payments
        FROM payment
        WHERE invoice_id = NEW.invoice_id AND status = 'completed';

        -- Determine new status
        IF total_payments >= invoice_total THEN
            new_status := 'paid';
        ELSIF total_payments > 0 THEN
            new_status := 'partially_paid';
        ELSE
            new_status := 'sent'; -- Assume it was sent if payments are being recorded
        END IF;

        -- Update invoice
        UPDATE invoice
        SET
            amount_paid = total_payments,
            status = new_status,
            first_payment_at = COALESCE(first_payment_at,
                CASE WHEN total_payments > 0 THEN now() ELSE NULL END)
        WHERE id = NEW.invoice_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Auto-generate numbers for various entities
CREATE OR REPLACE FUNCTION generate_quote_number()
RETURNS TRIGGER AS $$
DECLARE
    next_num integer;
    org_prefix text;
BEGIN
    SELECT slug INTO org_prefix FROM organization WHERE id = NEW.org_id;

    SELECT COALESCE(MAX(CAST(substring(quote_number FROM '\d+$') AS integer)), 0) + 1
    INTO next_num
    FROM sales_quote
    WHERE org_id = NEW.org_id AND quote_number ~ '^[A-Z]+-Q-\d+$';

    NEW.quote_number := UPPER(org_prefix) || '-Q-' || LPAD(next_num::text, 6, '0');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TRIGGER AS $$
DECLARE
    next_num integer;
    org_prefix text;
BEGIN
    SELECT slug INTO org_prefix FROM organization WHERE id = NEW.org_id;

    SELECT COALESCE(MAX(CAST(substring(order_number FROM '\d+$') AS integer)), 0) + 1
    INTO next_num
    FROM sales_order
    WHERE org_id = NEW.org_id AND order_number ~ '^[A-Z]+-SO-\d+$';

    NEW.order_number := UPPER(org_prefix) || '-SO-' || LPAD(next_num::text, 6, '0');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION generate_invoice_number()
RETURNS TRIGGER AS $$
DECLARE
    next_num integer;
    org_prefix text;
BEGIN
    SELECT slug INTO org_prefix FROM organization WHERE id = NEW.org_id;

    SELECT COALESCE(MAX(CAST(substring(invoice_number FROM '\d+$') AS integer)), 0) + 1
    INTO next_num
    FROM invoice
    WHERE org_id = NEW.org_id AND invoice_number ~ '^[A-Z]+-INV-\d+$';

    NEW.invoice_number := UPPER(org_prefix) || '-INV-' || LPAD(next_num::text, 6, '0');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION generate_payment_number()
RETURNS TRIGGER AS $$
DECLARE
    next_num integer;
    org_prefix text;
BEGIN
    SELECT slug INTO org_prefix FROM organization WHERE id = NEW.org_id;

    SELECT COALESCE(MAX(CAST(substring(payment_number FROM '\d+$') AS integer)), 0) + 1
    INTO next_num
    FROM payment
    WHERE org_id = NEW.org_id AND payment_number ~ '^[A-Z]+-PAY-\d+$';

    NEW.payment_number := UPPER(org_prefix) || '-PAY-' || LPAD(next_num::text, 6, '0');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Track document access
CREATE OR REPLACE FUNCTION log_document_access()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO document_access_log (document_id, user_id, action)
    VALUES (NEW.id, auth.uid(), 'view');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Update campaign statistics
CREATE OR REPLACE FUNCTION update_campaign_stats()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE communication_campaign
    SET
        total_recipients = (
            SELECT COUNT(*) FROM communication_log
            WHERE campaign_id = COALESCE(NEW.campaign_id, OLD.campaign_id)
        ),
        successful_sends = (
            SELECT COUNT(*) FROM communication_log
            WHERE campaign_id = COALESCE(NEW.campaign_id, OLD.campaign_id)
            AND status IN ('sent', 'delivered')
        ),
        failed_sends = (
            SELECT COUNT(*) FROM communication_log
            WHERE campaign_id = COALESCE(NEW.campaign_id, OLD.campaign_id)
            AND status IN ('failed', 'bounced')
        )
    WHERE id = COALESCE(NEW.campaign_id, OLD.campaign_id);

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- APPLY ENHANCED TRIGGERS
-- =====================================================

-- Updated timestamp triggers for new tables
CREATE TRIGGER update_customer_contact_updated_at BEFORE UPDATE ON customer_contact FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_lead_updated_at BEFORE UPDATE ON lead FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_opportunity_updated_at BEFORE UPDATE ON opportunity FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_crm_activity_updated_at BEFORE UPDATE ON crm_activity FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_product_updated_at BEFORE UPDATE ON product FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_price_list_updated_at BEFORE UPDATE ON price_list FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_product_price_updated_at BEFORE UPDATE ON product_price FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sales_quote_updated_at BEFORE UPDATE ON sales_quote FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sales_order_updated_at BEFORE UPDATE ON sales_order FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sales_order_item_updated_at BEFORE UPDATE ON sales_order_item FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_account_updated_at BEFORE UPDATE ON account FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_tax_rate_updated_at BEFORE UPDATE ON tax_rate FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_invoice_updated_at BEFORE UPDATE ON invoice FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_payment_updated_at BEFORE UPDATE ON payment FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_document_updated_at BEFORE UPDATE ON document FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_communication_template_updated_at BEFORE UPDATE ON communication_template FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_communication_campaign_updated_at BEFORE UPDATE ON communication_campaign FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_quality_control_updated_at BEFORE UPDATE ON quality_control FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Business logic triggers
CREATE TRIGGER update_quote_total_trigger AFTER INSERT OR UPDATE OR DELETE ON sales_quote_item FOR EACH ROW EXECUTE FUNCTION update_quote_total();
CREATE TRIGGER update_order_total_trigger AFTER INSERT OR UPDATE OR DELETE ON sales_order_item FOR EACH ROW EXECUTE FUNCTION update_order_total();
CREATE TRIGGER update_invoice_total_trigger AFTER INSERT OR UPDATE OR DELETE ON invoice_item FOR EACH ROW EXECUTE FUNCTION update_invoice_total();
CREATE TRIGGER update_invoice_payment_status_trigger AFTER INSERT OR UPDATE ON payment FOR EACH ROW EXECUTE FUNCTION update_invoice_payment_status();

-- Auto-generate number triggers
CREATE TRIGGER generate_quote_number_trigger BEFORE INSERT ON sales_quote
    FOR EACH ROW WHEN (NEW.quote_number IS NULL OR NEW.quote_number = '')
    EXECUTE FUNCTION generate_quote_number();

CREATE TRIGGER generate_order_number_trigger BEFORE INSERT ON sales_order
    FOR EACH ROW WHEN (NEW.order_number IS NULL OR NEW.order_number = '')
    EXECUTE FUNCTION generate_order_number();

CREATE TRIGGER generate_invoice_number_trigger BEFORE INSERT ON invoice
    FOR EACH ROW WHEN (NEW.invoice_number IS NULL OR NEW.invoice_number = '')
    EXECUTE FUNCTION generate_invoice_number();

CREATE TRIGGER generate_payment_number_trigger BEFORE INSERT ON payment
    FOR EACH ROW WHEN (NEW.payment_number IS NULL OR NEW.payment_number = '')
    EXECUTE FUNCTION generate_payment_number();

-- Communication tracking
CREATE TRIGGER update_campaign_stats_trigger AFTER INSERT OR UPDATE OR DELETE ON communication_log FOR EACH ROW EXECUTE FUNCTION update_campaign_stats();

-- =====================================================
-- MATERIALIZED VIEWS FOR ANALYTICS
-- =====================================================

-- Customer analytics view
CREATE MATERIALIZED VIEW customer_analytics AS
SELECT
    c.id,
    c.org_id,
    c.name,
    c.segment,
    c.status,
    c.lifetime_value,
    c.acquisition_date,
    c.last_interaction_date,
    COUNT(DISTINCT so.id) as total_orders,
    COALESCE(SUM(so.total_amount), 0) as total_order_value,
    COUNT(DISTINCT i.id) as total_invoices,
    COALESCE(SUM(i.total_amount), 0) as total_invoiced,
    COALESCE(SUM(i.amount_paid), 0) as total_paid,
    COUNT(DISTINCT st.id) as total_tickets,
    COUNT(DISTINCT ci.id) as total_interactions,
    AVG(CASE WHEN ci.sentiment IS NOT NULL THEN
        CASE ci.sentiment
            WHEN 'very_positive' THEN 5
            WHEN 'positive' THEN 4
            WHEN 'neutral' THEN 3
            WHEN 'negative' THEN 2
            WHEN 'very_negative' THEN 1
        END
    END) as avg_sentiment_score
FROM customer c
LEFT JOIN sales_order so ON c.id = so.customer_id
LEFT JOIN invoice i ON c.id = i.customer_id
LEFT JOIN support_ticket st ON c.id = st.customer_id
LEFT JOIN customer_interaction ci ON c.id = ci.customer_id
GROUP BY c.id, c.org_id, c.name, c.segment, c.status, c.lifetime_value, c.acquisition_date, c.last_interaction_date;

-- Create unique index for concurrent refresh
CREATE UNIQUE INDEX idx_customer_analytics_id ON customer_analytics(id);

-- Sales performance view
CREATE MATERIALIZED VIEW sales_performance AS
SELECT
    org_id,
    DATE_TRUNC('month', order_date) as month,
    COUNT(*) as order_count,
    SUM(total_amount) as total_revenue,
    AVG(total_amount) as avg_order_value,
    COUNT(DISTINCT customer_id) as unique_customers,
    SUM(total_amount) FILTER (WHERE status = 'completed') as completed_revenue,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_orders
FROM sales_order
WHERE order_date >= CURRENT_DATE - INTERVAL '24 months'
GROUP BY org_id, DATE_TRUNC('month', order_date);

-- Create unique index for concurrent refresh
CREATE UNIQUE INDEX idx_sales_performance_org_month ON sales_performance(org_id, month);

-- Inventory performance view
CREATE MATERIALIZED VIEW inventory_performance AS
SELECT
    ii.org_id,
    ii.id as inventory_item_id,
    ii.sku,
    ii.name,
    ii.category,
    ii.quantity_on_hand,
    ii.quantity_reserved,
    ii.reorder_point,
    ii.unit_price,
    COUNT(DISTINCT soi.order_id) as orders_count,
    COALESCE(SUM(soi.quantity), 0) as total_sold,
    COALESCE(SUM(soi.line_total), 0) as total_revenue,
    CASE
        WHEN ii.quantity_on_hand <= ii.reorder_point THEN 'low_stock'
        WHEN ii.quantity_on_hand = 0 THEN 'out_of_stock'
        ELSE 'in_stock'
    END as stock_status,
    ii.quantity_on_hand * ii.unit_price as inventory_value
FROM inventory_item ii
LEFT JOIN product p ON ii.id = p.inventory_item_id
LEFT JOIN sales_order_item soi ON p.id = soi.product_id
LEFT JOIN sales_order so ON soi.order_id = so.id AND so.status != 'cancelled'
WHERE ii.is_active = true
GROUP BY ii.org_id, ii.id, ii.sku, ii.name, ii.category, ii.quantity_on_hand,
         ii.quantity_reserved, ii.reorder_point, ii.unit_price;

-- Create unique index for concurrent refresh
CREATE UNIQUE INDEX idx_inventory_performance_item ON inventory_performance(inventory_item_id);

-- Financial overview view
CREATE MATERIALIZED VIEW financial_overview AS
SELECT
    org_id,
    DATE_TRUNC('month', invoice_date) as month,
    COUNT(*) as invoice_count,
    SUM(total_amount) as total_invoiced,
    SUM(amount_paid) as total_collected,
    SUM(amount_due) as total_outstanding,
    COUNT(*) FILTER (WHERE status = 'overdue') as overdue_count,
    SUM(amount_due) FILTER (WHERE status = 'overdue') as overdue_amount,
    AVG(due_date - invoice_date) as avg_payment_terms_days
FROM invoice
WHERE invoice_date >= CURRENT_DATE - INTERVAL '24 months'
GROUP BY org_id, DATE_TRUNC('month', invoice_date);

-- Create unique index for concurrent refresh
CREATE UNIQUE INDEX idx_financial_overview_org_month ON financial_overview(org_id, month);

-- =====================================================
-- FUNCTIONS FOR MATERIALIZED VIEW REFRESH
-- =====================================================

CREATE OR REPLACE FUNCTION refresh_analytics_views()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY customer_analytics;
    REFRESH MATERIALIZED VIEW CONCURRENTLY sales_performance;
    REFRESH MATERIALIZED VIEW CONCURRENTLY inventory_performance;
    REFRESH MATERIALIZED VIEW CONCURRENTLY financial_overview;
END;
$$ LANGUAGE plpgsql;

-- Schedule materialized view refresh (requires pg_cron extension)
-- SELECT cron.schedule('refresh-analytics', '0 2 * * *', 'SELECT refresh_analytics_views();');

-- =====================================================
-- SCHEMA ENHANCEMENT COMPLETE
-- =====================================================
--
-- This comprehensive schema enhancement adds:
-- 1. Complete CRM with leads, opportunities, activities
-- 2. Full sales cycle: quotes, orders, invoicing, payments
-- 3. Financial management with GL, tax handling
-- 4. Enhanced supply chain with quality control
-- 5. Document management with version control
-- 6. Communication system with templates and campaigns
-- 7. Advanced security with API keys, 2FA, session tracking
-- 8. Performance optimization with strategic indexing
-- 9. Analytics foundation with materialized views
-- 10. Comprehensive audit trails and RLS policies
--
-- The schema is designed for:
-- - Multi-tenant SaaS applications
-- - Enterprise-grade performance and security
-- - GDPR compliance with audit trails
-- - Horizontal scaling with partitioning
-- - Real-time analytics and reporting
-- - Integration with external systems
--
-- Next steps:
-- 1. Apply RLS policies to existing tables
-- 2. Create API endpoints for all new functionality
-- 3. Implement real-time subscriptions
-- 4. Add advanced analytics and ML features
-- 5. Set up automated backup and disaster recovery
-- =====================================================