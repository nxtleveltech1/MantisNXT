-- ============================================================================
-- Migration: 0021_comprehensive_auth_system_FIXED.sql
-- Description: Comprehensive Role-Based Authentication System (ALL CRITICAL ISSUES FIXED)
-- Author: AS Team (Auth & Security)
-- Date: 2025-11-04
-- Version: 2.0 (EMERGENCY FIX)
-- Dependencies: Requires 0001_prerequisite_core_tables.sql
--
-- FIXES APPLIED:
-- Γ£à Issue #1: Circular FK on suspended_by (now DEFERRABLE)
-- Γ£à Issue #2: Stack Auth enforced as the only provider (explicit constraints)
-- Γ£à Issue #3: Basic RLS policies (optimized versions in 0022)
-- Γ£à Issue #4: Essential composite indexes added (advanced indexes in 0022)
-- Γ£à Issue #5: 2FA secrets prepared for encryption (encrypted in 0022)
-- Γ£à Issues #6-10: Advanced features in 0022_critical_fixes.sql
-- ============================================================================

BEGIN;

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto"; -- For 2FA encryption

-- ============================================================================
-- PART 1: ENUMS AND TYPES
-- ============================================================================

-- User role types
DO $$ BEGIN
    CREATE TYPE user_role_type AS ENUM (
        'super_admin',
        'admin',
        'manager',
        'user',
        'viewer'
    );
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- Permission action types
DO $$ BEGIN
    CREATE TYPE permission_action AS ENUM (
        'create',
        'read',
        'update',
        'delete',
        'manage',
        'execute'
    );
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- Session status
DO $$ BEGIN
    CREATE TYPE session_status AS ENUM (
        'active',
        'expired',
        'revoked',
        'suspicious'
    );
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- Audit event types
DO $$ BEGIN
    CREATE TYPE audit_event_type AS ENUM (
        'login',
        'logout',
        'login_failed',
        'password_changed',
        'password_reset_requested',
        'password_reset_completed',
        'two_factor_enabled',
        'two_factor_disabled',
        'two_factor_verified',
        'role_changed',
        'permission_granted',
        'permission_revoked',
        'user_created',
        'user_updated',
        'user_deleted',
        'user_suspended',
        'user_activated',
        'session_created',
        'session_terminated',
        'security_event',
        'data_export',
        'data_import',
        'settings_changed'
    );
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- Employment equity (BEE compliance - South African)
DO $$ BEGIN
    CREATE TYPE employment_equity_type AS ENUM (
        'african',
        'coloured',
        'indian',
        'white',
        'other',
        'prefer_not_to_say'
    );
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- BEE status levels
DO $$ BEGIN
    CREATE TYPE bee_status_type AS ENUM (
        'level_1',
        'level_2',
        'level_3',
        'level_4',
        'level_5',
        'level_6',
        'level_7',
        'level_8',
        'non_compliant'
    );
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- ============================================================================
-- PART 2: CORE AUTHENTICATION TABLES
-- ============================================================================

-- Enhanced users table
--
-- AUTH PROVIDER STRATEGY (FIX #2):
-- Stack Auth (Neon) is the sole identity provider for this schema
-- - stack_auth_user_id: PRIMARY identifier issued by Stack Auth
-- Every row must have a valid Stack Auth identity before it is usable
--
CREATE TABLE IF NOT EXISTS auth.users_extended (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- ========================================================================
    -- AUTH PROVIDER LINKS
    -- ========================================================================

    -- PRIMARY: Stack Auth (Neon Auth) - Use this for NEW users
    stack_auth_user_id TEXT UNIQUE, -- Stack Auth user ID (primary identifier)
    stack_auth_provider TEXT, -- Provider: 'stack', 'google', 'github', etc.

    -- ========================================================================
    -- BASIC INFORMATION
    -- ========================================================================

    email TEXT NOT NULL UNIQUE,
    email_verified BOOLEAN DEFAULT FALSE,
    email_verified_at TIMESTAMPTZ,

    -- Profile
    first_name TEXT,
    last_name TEXT,
    display_name TEXT NOT NULL,
    avatar_url TEXT,
    phone TEXT,
    mobile TEXT,

    -- ========================================================================
    -- ORGANIZATION & EMPLOYMENT
    -- ========================================================================

    org_id UUID NOT NULL REFERENCES organization(id) ON DELETE CASCADE,
    department TEXT,
    job_title TEXT,
    employee_id TEXT,

    -- South African compliance fields
    id_number TEXT, -- SA ID number
    employment_equity employment_equity_type,
    bee_status bee_status_type,

    -- Address
    address_street TEXT,
    address_suburb TEXT,
    address_city TEXT,
    address_province TEXT,
    address_postal_code TEXT,
    address_country TEXT DEFAULT 'South Africa',

    -- ========================================================================
    -- STATUS & SECURITY
    -- ========================================================================

    is_active BOOLEAN DEFAULT TRUE,
    is_suspended BOOLEAN DEFAULT FALSE,
    suspended_at TIMESTAMPTZ,

    -- FIX #1: Make suspended_by DEFERRABLE to allow circular references
    suspended_by UUID,
    suspension_reason TEXT,

    -- Password (for local auth, nullable if using external provider)
    password_hash TEXT,
    password_changed_at TIMESTAMPTZ,
    password_reset_token TEXT,
    password_reset_expires_at TIMESTAMPTZ,
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMPTZ,

    -- ========================================================================
    -- TWO-FACTOR AUTHENTICATION
    -- ========================================================================

    two_factor_enabled BOOLEAN DEFAULT FALSE,

    -- FIX #5: Prepared for encryption (will be encrypted in migration 0022)
    -- NOTE: Store as TEXT now, will be converted to BYTEA with encryption
    two_factor_secret TEXT, -- TOTP secret (will be encrypted)
    two_factor_backup_codes TEXT[], -- Backup codes (will be encrypted)
    two_factor_enabled_at TIMESTAMPTZ,

    -- ========================================================================
    -- SESSION & ACTIVITY TRACKING
    -- ========================================================================

    last_login_at TIMESTAMPTZ,
    last_login_ip INET,
    last_activity_at TIMESTAMPTZ,

    -- ========================================================================
    -- METADATA
    -- ========================================================================

    metadata JSONB DEFAULT '{}'::JSONB,
    preferences JSONB DEFAULT '{}'::JSONB,

    -- ========================================================================
    -- TIMESTAMPS
    -- ========================================================================

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ, -- Soft delete

    -- ========================================================================
    -- CONSTRAINTS
    -- ========================================================================

    CONSTRAINT valid_email CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    CONSTRAINT valid_display_name CHECK (LENGTH(display_name) >= 1 AND LENGTH(display_name) <= 100),
    CONSTRAINT valid_phone CHECK (phone IS NULL OR phone ~ '^\+?[0-9\s\-\(\)]+$'),

    -- FIX #2: Ensure at least ONE auth provider is set
    CONSTRAINT stack_auth_required CHECK (stack_auth_user_id IS NOT NULL)
);

-- FIX #1: Add DEFERRABLE constraint for suspended_by after table creation
ALTER TABLE auth.users_extended
ADD CONSTRAINT fk_suspended_by
FOREIGN KEY (suspended_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED; -- Checked at transaction commit, not row insert

-- ========================================================================
-- FIX #4: Essential Composite Indexes
-- ========================================================================

-- Organization + status queries (most common pattern)
CREATE INDEX IF NOT EXISTS idx_users_extended_org_active
ON auth.users_extended(org_id, is_active) WHERE is_active = TRUE;

CREATE INDEX IF NOT EXISTS idx_users_extended_org_email
ON auth.users_extended(org_id, email) WHERE is_active = TRUE;

-- Department queries
CREATE INDEX IF NOT EXISTS idx_users_extended_org_dept
ON auth.users_extended(org_id, department) WHERE is_active = TRUE;

-- Auth provider lookups
CREATE INDEX IF NOT EXISTS idx_users_extended_stack_auth
ON auth.users_extended(stack_auth_user_id) WHERE stack_auth_user_id IS NOT NULL;

-- Activity tracking
CREATE INDEX IF NOT EXISTS idx_users_extended_last_activity
ON auth.users_extended(last_activity_at DESC) WHERE is_active = TRUE;

-- Security: locked/suspended users
CREATE INDEX IF NOT EXISTS idx_users_extended_locked
ON auth.users_extended(locked_until) WHERE locked_until IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_users_extended_suspended
ON auth.users_extended(is_suspended) WHERE is_suspended = TRUE;

-- ============================================================================
-- PART 3: ROLES AND PERMISSIONS
-- ============================================================================

-- Roles table (hierarchical role definitions)
CREATE TABLE IF NOT EXISTS auth.roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id) ON DELETE CASCADE,

    -- Role details
    name TEXT NOT NULL,
    slug TEXT NOT NULL, -- URL-friendly identifier
    description TEXT,

    -- Role type (system-defined or custom)
    is_system_role BOOLEAN DEFAULT FALSE, -- Cannot be deleted if true
    role_level INTEGER DEFAULT 0, -- Higher = more permissions

    -- Hierarchy (FIX #6: Validation trigger will be added in 0022)
    parent_role_id UUID, -- Will add DEFERRABLE FK below

    -- Status
    is_active BOOLEAN DEFAULT TRUE,

    -- Metadata
    metadata JSONB DEFAULT '{}'::JSONB,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID, -- Will add FK below

    -- Constraints
    CONSTRAINT unique_role_slug_per_org UNIQUE(org_id, slug),
    CONSTRAINT valid_role_name CHECK (LENGTH(name) >= 2 AND LENGTH(name) <= 50),
    CONSTRAINT valid_role_slug CHECK (slug ~ '^[a-z0-9_-]+$'),
    CONSTRAINT valid_role_level CHECK (role_level >= 0 AND role_level <= 100)
);

-- Add DEFERRABLE FKs for roles
ALTER TABLE auth.roles
ADD CONSTRAINT fk_parent_role
FOREIGN KEY (parent_role_id)
REFERENCES auth.roles(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

ALTER TABLE auth.roles
ADD CONSTRAINT fk_created_by_user
FOREIGN KEY (created_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

-- Permissions table (atomic permission definitions)
CREATE TABLE IF NOT EXISTS auth.permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Permission details
    name TEXT NOT NULL UNIQUE, -- e.g., 'users:read', 'orders:create'
    resource TEXT NOT NULL, -- e.g., 'users', 'orders', 'inventory'
    action permission_action NOT NULL,
    description TEXT,

    -- Conditions for attribute-based access control (ABAC)
    conditions JSONB DEFAULT '[]'::JSONB, -- Array of condition objects

    -- System permission (cannot be deleted)
    is_system_permission BOOLEAN DEFAULT FALSE,

    -- Metadata
    metadata JSONB DEFAULT '{}'::JSONB,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID, -- FIX #9: Added creator tracking

    -- Constraints
    CONSTRAINT unique_permission_resource_action UNIQUE(resource, action),
    CONSTRAINT valid_permission_name CHECK (name ~ '^[a-z0-9_:]+$')
);

-- Add FK for created_by (DEFERRABLE)
ALTER TABLE auth.permissions
ADD CONSTRAINT fk_permission_created_by
FOREIGN KEY (created_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

-- Role-Permission mapping (many-to-many)
CREATE TABLE IF NOT EXISTS auth.role_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    role_id UUID NOT NULL REFERENCES auth.roles(id) ON DELETE CASCADE,
    permission_id UUID NOT NULL REFERENCES auth.permissions(id) ON DELETE CASCADE,

    -- Optional constraints/conditions for this specific assignment
    constraints JSONB DEFAULT '{}'::JSONB,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    granted_by UUID,

    -- Constraints
    CONSTRAINT unique_role_permission UNIQUE(role_id, permission_id)
);

-- Add FK for granted_by
ALTER TABLE auth.role_permissions
ADD CONSTRAINT fk_granted_by_user
FOREIGN KEY (granted_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

-- User-Role mapping (many-to-many)
CREATE TABLE IF NOT EXISTS auth.user_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users_extended(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES auth.roles(id) ON DELETE CASCADE,

    -- Effective dates (for temporary role assignments)
    effective_from TIMESTAMPTZ DEFAULT NOW(),
    effective_until TIMESTAMPTZ,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    assigned_by UUID,

    -- Constraints
    CONSTRAINT unique_user_role UNIQUE(user_id, role_id),
    CONSTRAINT valid_effective_dates CHECK (
        effective_until IS NULL OR effective_until > effective_from
    )
);

-- Add FK for assigned_by
ALTER TABLE auth.user_roles
ADD CONSTRAINT fk_assigned_by_user
FOREIGN KEY (assigned_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

-- User-specific permission overrides (for granular control)
CREATE TABLE IF NOT EXISTS auth.user_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users_extended(id) ON DELETE CASCADE,
    permission_id UUID NOT NULL REFERENCES auth.permissions(id) ON DELETE CASCADE,

    -- Grant or deny (allows explicit denials)
    is_granted BOOLEAN NOT NULL DEFAULT TRUE,

    -- Optional constraints/conditions
    constraints JSONB DEFAULT '{}'::JSONB,

    -- Effective dates
    effective_from TIMESTAMPTZ DEFAULT NOW(),
    effective_until TIMESTAMPTZ,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    granted_by UUID,

    -- Constraints
    CONSTRAINT unique_user_permission UNIQUE(user_id, permission_id)
);

-- Add FK for granted_by
ALTER TABLE auth.user_permissions
ADD CONSTRAINT fk_user_perm_granted_by
FOREIGN KEY (granted_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

-- ========================================================================
-- FIX #4: Composite Indexes for Roles/Permissions
-- ========================================================================

CREATE INDEX IF NOT EXISTS idx_roles_org_slug ON auth.roles(org_id, slug);
CREATE INDEX IF NOT EXISTS idx_roles_org_active ON auth.roles(org_id, is_active) WHERE is_active = TRUE;
CREATE INDEX IF NOT EXISTS idx_roles_parent ON auth.roles(parent_role_id) WHERE parent_role_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_role_perms_role ON auth.role_permissions(role_id);
CREATE INDEX IF NOT EXISTS idx_role_perms_perm ON auth.role_permissions(permission_id);
CREATE INDEX IF NOT EXISTS idx_user_roles_user_active ON auth.user_roles(user_id) WHERE effective_until IS NULL OR effective_until > NOW();
CREATE INDEX IF NOT EXISTS idx_user_roles_role ON auth.user_roles(role_id);
CREATE INDEX IF NOT EXISTS idx_user_perms_user_granted ON auth.user_permissions(user_id, is_granted) WHERE effective_until IS NULL OR effective_until > NOW();
CREATE INDEX IF NOT EXISTS idx_permissions_resource_action ON auth.permissions(resource, action);

-- ============================================================================
-- PART 4: SESSION MANAGEMENT
-- ============================================================================

-- Active sessions table (tracks all user sessions)
CREATE TABLE IF NOT EXISTS auth.user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users_extended(id) ON DELETE CASCADE,

    -- Session tokens
    session_token TEXT NOT NULL UNIQUE,
    refresh_token TEXT UNIQUE,

    -- Device information
    device_name TEXT,
    device_type TEXT, -- 'desktop', 'mobile', 'tablet'
    device_fingerprint TEXT,
    user_agent TEXT,

    -- Location
    ip_address INET NOT NULL,
    country TEXT,
    city TEXT,

    -- Status
    status session_status DEFAULT 'active',

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    last_activity_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,
    revoked_at TIMESTAMPTZ,
    revoked_by UUID,
    revocation_reason TEXT,

    -- Metadata
    metadata JSONB DEFAULT '{}'::JSONB,

    -- Constraints
    CONSTRAINT valid_expiry CHECK (expires_at > created_at)
);

-- Add FK for revoked_by
ALTER TABLE auth.user_sessions
ADD CONSTRAINT fk_revoked_by_user
FOREIGN KEY (revoked_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

-- ========================================================================
-- FIX #4: Session Indexes (optimized for cleanup and queries)
-- ========================================================================

CREATE INDEX IF NOT EXISTS idx_sessions_user_status ON auth.user_sessions(user_id, status);
CREATE INDEX IF NOT EXISTS idx_sessions_token ON auth.user_sessions(session_token) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_sessions_active ON auth.user_sessions(status, expires_at) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_sessions_expired ON auth.user_sessions(expires_at) WHERE status = 'active' AND expires_at < NOW();

-- FIX #7: Session cleanup will be added in migration 0022

-- ============================================================================
-- PART 5: ENHANCED AUDIT LOGGING
-- ============================================================================

-- Comprehensive audit trail
-- FIX #8: Partitioning strategy will be applied in migration 0022
CREATE TABLE IF NOT EXISTS auth.audit_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Organization and user
    org_id UUID REFERENCES organization(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users_extended(id) ON DELETE SET NULL,
    session_id UUID REFERENCES auth.user_sessions(id) ON DELETE SET NULL,

    -- Event details
    event_type audit_event_type NOT NULL,
    event_category TEXT, -- 'authentication', 'authorization', 'data_access', etc.
    severity TEXT DEFAULT 'info', -- 'debug', 'info', 'warning', 'error', 'critical'

    -- Resource details
    resource_type TEXT, -- 'user', 'role', 'permission', etc.
    resource_id UUID,
    resource_name TEXT,

    -- Action details
    action TEXT NOT NULL, -- Detailed action description
    status TEXT DEFAULT 'success', -- 'success', 'failure', 'warning'

    -- Changes
    old_values JSONB,
    new_values JSONB,
    changes JSONB, -- Computed diff

    -- Context
    ip_address INET,
    user_agent TEXT,
    request_id TEXT,

    -- Metadata
    metadata JSONB DEFAULT '{}'::JSONB,
    error_message TEXT,

    -- Timestamp
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints
    CONSTRAINT valid_severity CHECK (severity IN ('debug', 'info', 'warning', 'error', 'critical')),
    CONSTRAINT valid_status CHECK (status IN ('success', 'failure', 'warning', 'pending'))
);

-- ========================================================================
-- FIX #4: Audit Event Indexes (optimized for queries)
-- ========================================================================

CREATE INDEX IF NOT EXISTS idx_audit_org_created ON auth.audit_events(org_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_user_created ON auth.audit_events(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_event_type_created ON auth.audit_events(event_type, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_severity ON auth.audit_events(severity, created_at DESC) WHERE severity IN ('error', 'critical');
CREATE INDEX IF NOT EXISTS idx_audit_resource ON auth.audit_events(resource_type, resource_id) WHERE resource_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_audit_session ON auth.audit_events(session_id) WHERE session_id IS NOT NULL;

-- Login history (optimized for quick lookups)
CREATE TABLE IF NOT EXISTS auth.login_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users_extended(id) ON DELETE CASCADE,

    -- Attempt details
    email TEXT NOT NULL,
    success BOOLEAN NOT NULL,
    failure_reason TEXT,

    -- Location and device
    ip_address INET NOT NULL,
    user_agent TEXT,
    device_type TEXT,
    country TEXT,
    city TEXT,

    -- Two-factor
    two_factor_used BOOLEAN DEFAULT FALSE,

    -- Timestamp
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- Metadata
    metadata JSONB DEFAULT '{}'::JSONB
);

-- ========================================================================
-- FIX #4: Login History Indexes
-- ========================================================================

CREATE INDEX IF NOT EXISTS idx_login_user_created ON auth.login_history(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_login_email_created ON auth.login_history(email, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_login_failed ON auth.login_history(user_id, success, created_at DESC) WHERE success = FALSE;
CREATE INDEX IF NOT EXISTS idx_login_ip ON auth.login_history(ip_address, created_at DESC);

-- ============================================================================
-- PART 6: USER PREFERENCES AND CUSTOMIZATION
-- ============================================================================

-- User preferences (detailed settings)
CREATE TABLE IF NOT EXISTS auth.user_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE REFERENCES auth.users_extended(id) ON DELETE CASCADE,

    -- Localization
    language TEXT DEFAULT 'en',
    timezone TEXT DEFAULT 'Africa/Johannesburg',
    date_format TEXT DEFAULT 'dd/mm/yyyy',
    time_format TEXT DEFAULT '24h',
    currency TEXT DEFAULT 'ZAR',

    -- Notifications
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    notification_digest_frequency TEXT DEFAULT 'daily', -- 'realtime', 'daily', 'weekly', 'never'

    -- UI preferences
    theme TEXT DEFAULT 'light', -- 'light', 'dark', 'auto'
    sidebar_collapsed BOOLEAN DEFAULT FALSE,
    dashboard_layout JSONB DEFAULT '[]'::JSONB, -- Widget configuration
    quick_actions JSONB DEFAULT '[]'::JSONB,

    -- Privacy
    profile_visibility TEXT DEFAULT 'organization', -- 'public', 'organization', 'private'
    show_email BOOLEAN DEFAULT FALSE,
    show_phone BOOLEAN DEFAULT FALSE,

    -- Accessibility
    high_contrast BOOLEAN DEFAULT FALSE,
    reduced_motion BOOLEAN DEFAULT FALSE,
    screen_reader_optimized BOOLEAN DEFAULT FALSE,

    -- Other preferences
    preferences JSONB DEFAULT '{}'::JSONB,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_user_prefs_user ON auth.user_preferences(user_id);

-- ============================================================================
-- PART 7: SYSTEM CONFIGURATION
-- ============================================================================

-- System-wide configuration settings
CREATE TABLE IF NOT EXISTS auth.system_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id) ON DELETE CASCADE,

    -- Configuration key-value
    config_key TEXT NOT NULL,
    config_value JSONB NOT NULL,

    -- Metadata
    description TEXT,
    is_secret BOOLEAN DEFAULT FALSE, -- If true, value should be encrypted
    category TEXT, -- 'security', 'features', 'integrations', etc.

    -- Version control
    version INTEGER DEFAULT 1,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    updated_by UUID,

    -- Constraints
    CONSTRAINT unique_config_key_per_org UNIQUE(org_id, config_key)
);

-- Add FK for updated_by
ALTER TABLE auth.system_config
ADD CONSTRAINT fk_config_updated_by
FOREIGN KEY (updated_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

CREATE INDEX IF NOT EXISTS idx_sys_config_org_key ON auth.system_config(org_id, config_key);
CREATE INDEX IF NOT EXISTS idx_sys_config_category ON auth.system_config(category);

-- Feature flags
CREATE TABLE IF NOT EXISTS auth.feature_flags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID REFERENCES organization(id) ON DELETE CASCADE, -- NULL = global

    -- Flag details
    flag_key TEXT NOT NULL,
    flag_name TEXT NOT NULL,
    description TEXT,

    -- Status
    is_enabled BOOLEAN DEFAULT FALSE,

    -- Rollout (gradual feature activation)
    rollout_percentage INTEGER DEFAULT 100, -- 0-100
    rollout_user_ids UUID[], -- Specific users who have access
    rollout_rules JSONB DEFAULT '[]'::JSONB,

    -- Metadata
    metadata JSONB DEFAULT '{}'::JSONB,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID, -- FIX #9: Added creator tracking

    -- Constraints
    CONSTRAINT unique_flag_key_per_org UNIQUE(org_id, flag_key),
    CONSTRAINT valid_rollout_percentage CHECK (rollout_percentage >= 0 AND rollout_percentage <= 100)
);

-- Add FK for created_by
ALTER TABLE auth.feature_flags
ADD CONSTRAINT fk_flag_created_by
FOREIGN KEY (created_by)
REFERENCES auth.users_extended(id)
ON DELETE SET NULL
DEFERRABLE INITIALLY DEFERRED;

CREATE INDEX IF NOT EXISTS idx_feature_flags_org ON auth.feature_flags(org_id) WHERE org_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_feature_flags_enabled ON auth.feature_flags(is_enabled) WHERE is_enabled = TRUE;

-- ============================================================================
-- PART 8: HELPER FUNCTIONS
-- ============================================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION auth.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to check if user has permission
CREATE OR REPLACE FUNCTION auth.user_has_permission(
    p_user_id UUID,
    p_permission_name TEXT
) RETURNS BOOLEAN AS $$
DECLARE
    v_has_permission BOOLEAN;
BEGIN
    -- Check direct user permission grants
    SELECT EXISTS(
        SELECT 1
        FROM auth.user_permissions up
        JOIN auth.permissions p ON up.permission_id = p.id
        WHERE up.user_id = p_user_id
          AND p.name = p_permission_name
          AND up.is_granted = TRUE
          AND (up.effective_until IS NULL OR up.effective_until > NOW())
    ) INTO v_has_permission;

    IF v_has_permission THEN
        RETURN TRUE;
    END IF;

    -- Check permissions through roles
    SELECT EXISTS(
        SELECT 1
        FROM auth.user_roles ur
        JOIN auth.role_permissions rp ON ur.role_id = rp.role_id
        JOIN auth.permissions p ON rp.permission_id = p.id
        WHERE ur.user_id = p_user_id
          AND p.name = p_permission_name
          AND (ur.effective_until IS NULL OR ur.effective_until > NOW())
    ) INTO v_has_permission;

    RETURN v_has_permission;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get all user permissions
CREATE OR REPLACE FUNCTION auth.get_user_permissions(p_user_id UUID)
RETURNS TABLE(permission_name TEXT, resource TEXT, action TEXT) AS $$
BEGIN
    RETURN QUERY
    -- Direct permissions
    SELECT DISTINCT p.name, p.resource, p.action::TEXT
    FROM auth.user_permissions up
    JOIN auth.permissions p ON up.permission_id = p.id
    WHERE up.user_id = p_user_id
      AND up.is_granted = TRUE
      AND (up.effective_until IS NULL OR up.effective_until > NOW())

    UNION

    -- Role-based permissions
    SELECT DISTINCT p.name, p.resource, p.action::TEXT
    FROM auth.user_roles ur
    JOIN auth.role_permissions rp ON ur.role_id = rp.role_id
    JOIN auth.permissions p ON rp.permission_id = p.id
    WHERE ur.user_id = p_user_id
      AND (ur.effective_until IS NULL OR ur.effective_until > NOW());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to log audit event
CREATE OR REPLACE FUNCTION auth.log_audit_event(
    p_org_id UUID,
    p_user_id UUID,
    p_event_type audit_event_type,
    p_action TEXT,
    p_resource_type TEXT DEFAULT NULL,
    p_resource_id UUID DEFAULT NULL,
    p_old_values JSONB DEFAULT NULL,
    p_new_values JSONB DEFAULT NULL,
    p_metadata JSONB DEFAULT '{}'::JSONB
) RETURNS UUID AS $$
DECLARE
    v_audit_id UUID;
BEGIN
    INSERT INTO auth.audit_events (
        org_id, user_id, event_type, action,
        resource_type, resource_id, old_values, new_values, metadata
    )
    VALUES (
        p_org_id, p_user_id, p_event_type, p_action,
        p_resource_type, p_resource_id, p_old_values, p_new_values, p_metadata
    )
    RETURNING id INTO v_audit_id;

    RETURN v_audit_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- PART 9: TRIGGERS
-- ============================================================================

-- Trigger: Update updated_at on users_extended
DROP TRIGGER IF EXISTS update_users_extended_updated_at ON auth.users_extended;
CREATE TRIGGER update_users_extended_updated_at
    BEFORE UPDATE ON auth.users_extended
    FOR EACH ROW
    EXECUTE FUNCTION auth.update_updated_at_column();

-- Trigger: Update updated_at on roles
DROP TRIGGER IF EXISTS update_roles_updated_at ON auth.roles;
CREATE TRIGGER update_roles_updated_at
    BEFORE UPDATE ON auth.roles
    FOR EACH ROW
    EXECUTE FUNCTION auth.update_updated_at_column();

-- Trigger: Update updated_at on user_preferences
DROP TRIGGER IF EXISTS update_user_preferences_updated_at ON auth.user_preferences;
CREATE TRIGGER update_user_preferences_updated_at
    BEFORE UPDATE ON auth.user_preferences
    FOR EACH ROW
    EXECUTE FUNCTION auth.update_updated_at_column();

-- Trigger: Update updated_at on system_config
DROP TRIGGER IF EXISTS update_system_config_updated_at ON auth.system_config;
CREATE TRIGGER update_system_config_updated_at
    BEFORE UPDATE ON auth.system_config
    FOR EACH ROW
    EXECUTE FUNCTION auth.update_updated_at_column();

-- Trigger: Audit user changes
CREATE OR REPLACE FUNCTION auth.audit_user_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        PERFORM auth.log_audit_event(
            NEW.org_id,
            NEW.id,
            'user_updated'::audit_event_type,
            'User profile updated',
            'user',
            NEW.id,
            to_jsonb(OLD),
            to_jsonb(NEW)
        );
    ELSIF TG_OP = 'INSERT' THEN
        PERFORM auth.log_audit_event(
            NEW.org_id,
            NEW.id,
            'user_created'::audit_event_type,
            'User account created',
            'user',
            NEW.id,
            NULL,
            to_jsonb(NEW)
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS audit_users_extended_changes ON auth.users_extended;
CREATE TRIGGER audit_users_extended_changes
    AFTER INSERT OR UPDATE ON auth.users_extended
    FOR EACH ROW
    EXECUTE FUNCTION auth.audit_user_changes();

-- ============================================================================
-- PART 10: ROW LEVEL SECURITY (RLS) POLICIES
-- FIX #3: Basic policies here, optimized versions in migration 0022
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE auth.users_extended ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.user_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.audit_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.login_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.system_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.feature_flags ENABLE ROW LEVEL SECURITY;

-- Basic RLS: Users can read their own data
DROP POLICY IF EXISTS users_select_own ON auth.users_extended;
CREATE POLICY users_select_own
    ON auth.users_extended FOR SELECT
    USING (id = auth.uid());

-- Basic RLS: Service role can do everything
DROP POLICY IF EXISTS users_service_all ON auth.users_extended;
CREATE POLICY users_service_all
    ON auth.users_extended FOR ALL
    TO service_role
    USING (true);

-- Basic RLS: Users can read their own sessions
DROP POLICY IF EXISTS sessions_select_own ON auth.user_sessions;
CREATE POLICY sessions_select_own
    ON auth.user_sessions FOR SELECT
    USING (user_id = auth.uid());

-- Basic RLS: Users can revoke their own sessions
DROP POLICY IF EXISTS sessions_delete_own ON auth.user_sessions;
CREATE POLICY sessions_delete_own
    ON auth.user_sessions FOR DELETE
    USING (user_id = auth.uid());

-- Basic RLS: Users can read/update their own preferences
DROP POLICY IF EXISTS preferences_select_own ON auth.user_preferences;
CREATE POLICY preferences_select_own
    ON auth.user_preferences FOR SELECT
    USING (user_id = auth.uid());

DROP POLICY IF EXISTS preferences_update_own ON auth.user_preferences;
CREATE POLICY preferences_update_own
    ON auth.user_preferences FOR UPDATE
    USING (user_id = auth.uid());

-- NOTE: More sophisticated RLS policies will be added in migration 0022

-- ============================================================================
-- PART 11: SEED DATA (SYSTEM PERMISSIONS)
-- ============================================================================

-- Insert system permissions (idempotent)
INSERT INTO auth.permissions (name, resource, action, description, is_system_permission) VALUES
    -- User management
    ('users:create', 'users', 'create', 'Create new users', TRUE),
    ('users:read', 'users', 'read', 'View user information', TRUE),
    ('users:update', 'users', 'update', 'Update user information', TRUE),
    ('users:delete', 'users', 'delete', 'Delete users', TRUE),
    ('users:manage', 'users', 'manage', 'Full user management access', TRUE),

    -- Role management
    ('roles:create', 'roles', 'create', 'Create new roles', TRUE),
    ('roles:read', 'roles', 'read', 'View roles', TRUE),
    ('roles:update', 'roles', 'update', 'Update roles', TRUE),
    ('roles:delete', 'roles', 'delete', 'Delete roles', TRUE),
    ('roles:manage', 'roles', 'manage', 'Full role management access', TRUE),

    -- Permission management
    ('permissions:read', 'permissions', 'read', 'View permissions', TRUE),
    ('permissions:manage', 'permissions', 'manage', 'Manage permissions', TRUE),

    -- System configuration
    ('system:read', 'system', 'read', 'View system configuration', TRUE),
    ('system:update', 'system', 'update', 'Update system configuration', TRUE),
    ('system:manage', 'system', 'manage', 'Full system management access', TRUE),

    -- Audit logs
    ('audit:read', 'audit', 'read', 'View audit logs', TRUE),

    -- Organization management
    ('organization:read', 'organization', 'read', 'View organization information', TRUE),
    ('organization:update', 'organization', 'update', 'Update organization information', TRUE),
    ('organization:manage', 'organization', 'manage', 'Full organization management', TRUE)
ON CONFLICT (resource, action) DO NOTHING;

-- ============================================================================
-- PART 12: COMMENTS AND DOCUMENTATION
-- ============================================================================

COMMENT ON TABLE auth.users_extended IS 'Extended user profiles with Stack Auth (Neon) integration';
COMMENT ON TABLE auth.roles IS 'Role definitions for RBAC system';
COMMENT ON TABLE auth.permissions IS 'Atomic permission definitions';
COMMENT ON TABLE auth.role_permissions IS 'Many-to-many mapping between roles and permissions';
COMMENT ON TABLE auth.user_roles IS 'User role assignments with temporal support';
COMMENT ON TABLE auth.user_permissions IS 'User-specific permission overrides';
COMMENT ON TABLE auth.user_sessions IS 'Active user sessions with device tracking';
COMMENT ON TABLE auth.audit_events IS 'Comprehensive audit trail for all system events';
COMMENT ON TABLE auth.login_history IS 'Login attempt history for security monitoring';
COMMENT ON TABLE auth.user_preferences IS 'User-specific preferences and customization';
COMMENT ON TABLE auth.system_config IS 'System-wide configuration settings';
COMMENT ON TABLE auth.feature_flags IS 'Feature flag management for gradual rollouts';

COMMENT ON COLUMN auth.users_extended.stack_auth_user_id IS 'PRIMARY: Stack Auth user ID (use for new users)';
COMMENT ON COLUMN auth.users_extended.suspended_by IS 'DEFERRABLE FK: User who suspended this account';
COMMENT ON COLUMN auth.users_extended.two_factor_secret IS 'TOTP secret (will be encrypted in migration 0022)';
COMMENT ON COLUMN auth.roles.parent_role_id IS 'DEFERRABLE FK: Parent role for hierarchy (cycle validation in 0022)';

-- ============================================================================
-- PART 13: VALIDATION
-- ============================================================================

DO $$
DECLARE
    v_table_count INTEGER := 0;
    v_perm_count INTEGER := 0;
BEGIN
    -- Count tables created
    SELECT COUNT(*) INTO v_table_count
    FROM information_schema.tables
    WHERE table_schema = 'auth'
    AND table_name IN ('users_extended', 'roles', 'permissions', 'user_roles',
                       'role_permissions', 'user_permissions', 'user_sessions',
                       'audit_events', 'login_history', 'user_preferences',
                       'system_config', 'feature_flags');

    -- Count permissions created
    SELECT COUNT(*) INTO v_perm_count FROM auth.permissions;

    RAISE NOTICE '';
    RAISE NOTICE 'Γ£à ============================================================';
    RAISE NOTICE 'Γ£à COMPREHENSIVE AUTH SYSTEM MIGRATION COMPLETE';
    RAISE NOTICE 'Γ£à ============================================================';
    RAISE NOTICE '';
    RAISE NOTICE '   Tables Created: % / 12', v_table_count;
    RAISE NOTICE '   System Permissions: %', v_perm_count;
    RAISE NOTICE '';
    RAISE NOTICE 'Γ£à FIXES APPLIED:';
    RAISE NOTICE '   Γ£ô Issue #1: Circular FK (suspended_by) - DEFERRABLE';
    RAISE NOTICE '   Γ£ô Issue #2: Auth Provider Strategy - Stack Auth PRIMARY';
    RAISE NOTICE '   Γ£ô Issue #3: Basic RLS Policies - Optimized in 0022';
    RAISE NOTICE '   Γ£ô Issue #4: Composite Indexes - Essential ones added';
    RAISE NOTICE '   Γ£ô Issue #5: 2FA Encryption - Prepared (encrypted in 0022)';
    RAISE NOTICE '   Γ£ô Issue #9: Creator Tracking - Added to key tables';
    RAISE NOTICE '';
    RAISE NOTICE 'ΓÜá∩╕Å  NEXT STEPS:';
    RAISE NOTICE '   1. Run migration 0022_critical_fixes.sql for advanced optimizations';
    RAISE NOTICE '   2. Create system roles per organization via application';
    RAISE NOTICE '   3. Configure Stack Auth integration';
    RAISE NOTICE '   4. Test authentication flows';
    RAISE NOTICE '';
    RAISE NOTICE '≡ƒôÜ DOCUMENTATION:';
    RAISE NOTICE '   - Auth Provider: Stack Auth (Neon)';
    RAISE NOTICE '   - Identity Provider: Stack Auth (Neon)';
    RAISE NOTICE '   - RLS: Enabled on all tables';
    RAISE NOTICE '   - Audit: Comprehensive event logging';
    RAISE NOTICE '';
END $$;

COMMIT;

-- ============================================================================
-- END OF MIGRATION
-- ============================================================================


